------------- Game Load -------------
repeat 
    task.wait(); 
until game:IsLoaded();

------------- Super Global -------------
GG = (getgenv and getgenv()) or _G or shared or false;
GG.GG = GG;

if not GG then
    return game:GetService("Players"):Kick("GG not found. Please report this bug in discord server and tell us your executor.");
end;

GG.LoaderSettings = GG.LoaderSettings or {
    AllowThemeEdit = false;
    AllowGraphicsEditor = false;
    AllowMusic = true;
};

GG.APINUMBER = "Luarify 2.9";

GG.Uni = "https://raw.githubusercontent.com/Yumiara/FlowRewrite/refs/heads/main/listfiles/Universal.lua";
GG.API_K = "https://raw.githubusercontent.com/Yumiara/FlowRewrite/refs/heads/main/API_K.lua";
GG.API_Q = [[if not Configs then return; end;]];

------------- Global API Setup -------------

if not GG.AlreadyLoadMain then
    for i=1, 3 do
        local GlobalOneRunCall, GlobalOneRunError = pcall(function()
            local OriginPrint = print;
            local OriginalWarn = warn;
            local OriginalError = error;

            GG.AllowDebug = true;

            GG.print = function(...) local txt = tos(...); if strfind(txt, "Debug") then if GG.AllowDebug then return OriginPrint(...); end; end; if strfind(txt, "Pelican") then return; end; return OriginPrint(...); end;
            GG.warn = function(...) local txt = tos(...); if strfind(txt, "Pelican") then return; end; return OriginalWarn(...); end;

            GG.lowesttime = 0.0000016689300537109375;
            GG.GameId = game.GameId;
            GG.PlaceId = game.PlaceId;

            GG.setc = (setclipboard or toclipboard) or nil;

            GG.tob = tobit or nil;

            GG.fireproximityprompt = fireproximityprompt or FireProximityPrompt;

            GG.setfpscap = (fpsunlock or fpsunlocker or setfps or setfpscap or setfpslimit or setfpsmax) or false;

            GG.dumpheap = dumpheap or debug.dumpheap;
            GG.getconstants = getconstants or debug.getconstants;
            GG.getproto = getproto or debug.getproto;
            GG.setmemorycategory = setmemorycategory or debug.setmemorycategory;
            GG.profilebegin = profilebegin or debug.profilebegin;
            GG.loadmodule = loadmodule or debug.loadmodule;
            GG.traceback = traceback or debug.traceback;
            GG.getinfo = getinfo or debug.getinfo;
            GG.getstack = getstack or debug.getstack;
            GG.isvalidlevel = isvalidlevel or debug.isvalidlevel;
            GG.getupvalues = getupvalues or debug.getupvalues;
            GG.getconstant = getconstant or debug.getconstant;
            GG.getfenv = getfenv or debug.getfenv;
            GG.getupvalue = getupvalue or debug.getupvalue;
            GG.getmemorycategory = getmemorycategory or debug.getmemorycategory;
            GG.resetmemorycategory = resetmemorycategory or debug.resetmemorycategory;
            GG.getprotos = getprotos or debug.getprotos;
            GG.dumpcodesize = dumpcodesize or debug.dumpcodesize;
            GG.setstack = setstack or debug.setstack;
            GG.profileend = profileend or debug.profileend;
            GG.dumprefs = dumprefs or debug.dumprefs;
            GG.validlevel = validlevel or debug.validlevel;
            GG.setupvalue = setupvalue or debug.setupvalue;
            GG.setconstant = setconstant or debug.setconstant;
            GG.getregistry = getregistry or debug.getregistry;
            GG.info = info or debug.info;

            GG.wait = wait;
            GG.delay = delay;
            GG.spawn = spawn;
            GG.tick = tick;

            GG.tos = tostring;
            GG.ton = tonumber;

            GG.tble = table;
            GG.tablein = tble.insert;
            GG.tablecl = tble.clear;
            GG.tablef = tble.find;
            GG.tsort = tble.sort;
            GG.tconcat = tble.concat;
            GG.tunpack = tble.unpack;
            GG.tabler = tble.remove;

            GG.tk = task;
            GG.twait = tk.wait;
            GG.tdefer = tk.tdefer;
            GG.tspawn = tk.spawn;
            GG.tcancel = tk.cancel;
            GG.tdelay = task.delay;
            GG.tdesyn = tk.desynchronize;
            GG.tsyn = tk.synchronize;

            GG.str = string;
            GG.strgsub = str.gsub;
            GG.strsub = str.sub;
            GG.strfind = str.find;
            GG.strlen = str.len;
            GG.strchar = str.char;
            GG.strbyte = str.byte;
            GG.strsplit = str.split;
            GG.strmatch = str.match;
            GG.strgmatch = str.gmatch;
            GG.strupper = str.upper;
            GG.strlower = str.lower;
            GG.strformat = str.format;
            GG.strpack = str.pack;
            GG.strpacksize = str.packsize;
            GG.strreverse = str.reverse;
            GG.strunpack = str.unpack;
            GG.strrep = str.rep;

            GG.mmaths = math;
            GG.mlog = mmaths.log;
            GG.mldexp = mmaths.ldexp;
            GG.mdeg = mmaths.deg;
            GG.mcosh = mmaths.cosh;
            GG.mround = mmaths.round;
            GG.mrandom = mmaths.random;
            GG.mfrexp = mmaths.frexp;
            GG.mtanh = mmaths.tanh;
            GG.mfloor = mmaths.floor;
            GG.mmax = mmaths.max;
            GG.msqrt = mmaths.sqrt;
            GG.mmodf = mmaths.modf;
            GG.mhuge = mmaths.huge;
            GG.mpow = mmaths.pow;
            GG.macos = mmaths.acos;
            GG.mtan = mmaths.tan;
            GG.mcos = mmaths.cos;
            GG.mpi = mmaths.pi;
            GG.matan = mmaths.atan;
            GG.mmap = mmaths.map;
            GG.msign = mmaths.sign;
            GG.mceil = mmaths.ceil;
            GG.mclamp = mmaths.clamp;
            GG.mnoise = mmaths.noise;
            GG.mabs = mmaths.abs;
            GG.mexp = mmaths.exp;
            GG.msinh = mmaths.sinh;
            GG.masin = mmaths.asin;
            GG.mmin = mmaths.min;
            GG.mrandomseed = mmaths.randomseed;
            GG.mfmod = mmaths.fmod;
            GG.mrad = mmaths.rad;
            GG.matan2 = mmaths.atan2;
            GG.mlog10 = mmaths.log10;
            GG.msin = mmaths.sin;
            GG.mlerp = mmaths.lerp;

            GG.Col3 = Color3;
            GG.fromRGB = Color3.fromRGB;
            GG.fromHex = Col3.fromHex;
            GG.fromHSV = Col3.fromHSV;
            GG.toHSV = Col3.toHSV;
            GG.new = Col3.new;

            GG.BCol = BrickColor;
            GG.BBlue = BCol.Blue;
            GG.BWhite = BCol.White;
            GG.BYellow = BCol.Yellow;
            GG.BRed = BCol.Red;
            GG.BGray = BCol.Gray;
            GG.Bpalette = BCol.palette;
            GG.BNew = BCol.New;
            GG.BBlack = BCol.Black;
            GG.BGreen = BCol.Green;
            GG.BRandom = BCol.Random;
            GG.BDarkGray = BCol.DarkGray;
            GG.Brandom = BCol.random;
            GG.Bnew = BCol.new;

            GG.Reg3 = Region3;
            GG.Regnew = Reg3.new;

            GG.Vec3 = Vector3.new;
            GG.Vec2 = Vector2.new;
            GG.CF = CFrame.new;
            
            GG.pir = pairs;
            GG.ipairs = ipairs;

            GG.pcal = pcall;
            GG.xpcal = xpcall;

            GG.Instancen = Instance.new;
            GG.fromExisting = Instance.fromExisting;

            GG.Dim2 = UDim2.new;
            GG.Dim = UDim.new;

            GG.queueOT = queueonteleport or queue_on_teleport or (syn and syn.queue_on_teleport) or (fluxus and fluxus.queue_on_teleport) or on_teleport or false;

            GG.LowerC = hookfunction or hookfunc;
            GG.UpperC = hookmetamethod;

            GG.GetPivot = function( object : Model ): nil
                return object:GetPivot(true);
            end;

            GG.PivotTo = function( object : Model , cframe : CFrame ): nil
                return object:PivotTo(cframe);
            end;

            GG.IsA = function( object : any , class : string )
                return object:IsA(class);
            end;

            GG.GetAttribute = function( object : any , attribute : string )
                return object:GetAttribute(attribute);
            end;
            GG.SetAttribute = function( object : any , attribute : string , value : any )
                return object:SetAttribute(attribute, value);
            end;

            GG.WaitForChild = function( object : Instance , name : string , timeout : number )
                return object:WaitForChild(name, timeout or nil);
            end;

            GG.FindFirstChild = function( object : any , name : string , isDescen : boolean )
                return object:FindFirstChild(name, isDescen or nil);
            end;
            GG.FindFirstChildOfClass = function( object : any , class : string )
                return object:FindFirstChildOfClass(class);
            end;
            GG.FindFirstChildWhichIsA = function( object : any , class : string , isDescen : boolean )
                return object:FindFirstChildWhichIsA(class, isDescen or nil);
            end;
            GG.FindFirstAncestor = function( object : any , name : string , isDescen : boolean )
                return object:FindFirstAncestor(name, isDescen or nil);
            end;
            GG.FindFirstAncestorOfClass = function( object : any , class : string )
                return object:FindFirstAncestorOfClass(class);
            end;
            GG.FindFirstAncestorWhichIsA = function( object : any , class : string , isDescen : boolean )
                return object:FindFirstAncestorWhichIsA(class, isDescen or nil);
            end;

            GG.GetService = function( service : string )
                return game:GetService(service);
            end;

            GG.GetChildren = function( object : Instance )
                return object:GetChildren();
            end;
            GG.GetDescendants = function( object : Instance )
                return object:GetDescendants();
            end;
            
            GG.Destroy = function( object : Instance )
                return object:Destroy(true);
            end;

            local tempwait : any = GG.twait;
            GG.twait = function( time : number )
                if time and time > 0 then
                    return tempwait(time);
                else
                    if time == nil then
                        return tempwait(time);
                    end;
                    return 0;
                end;
            end;

            GG.uncCheck2point1 = {};
            if getinfo then
                (GG.uncCheck2point1)["require"] = (require and getinfo(require).what) or false;
                (GG.uncCheck2point1)["fireproximityprompt"] = (fireproximityprompt and getinfo(fireproximityprompt).what) or false;
                (GG.uncCheck2point1)["getgc"] = (getgc and getinfo(getgc).what) or false;
                (GG.uncCheck2point1)["firetouchinterest"] = (firetouchinterest and getinfo(firetouchinterest).what) or false;
                (GG.uncCheck2point1)["request"] = (request and getinfo(request).what) or false;
                (GG.uncCheck2point1)["isnetworkowner"] = (isnetworkowner and getinfo(isnetworkowner).what) or false;
            end;

            GG.VirtualInputManager = GetService('VirtualInputManager');
            GG.CollectionService = GetService("CollectionService");
            GG.UserInputService = GetService("UserInputService");
            GG.TeleportService = GetService("TeleportService");
            GG.TextService = GetService("TextChatService");
            GG.TweenService = GetService("TweenService");
            GG.HttpService = GetService("HttpService");
            GG.StarterGui = GetService("StarterGui");
            GG.GuiService = GetService("GuiService");
            GG.R = GetService("ReplicatedStorage");
            GG.VU = GetService("VirtualUser");
            GG.H = GetService("RunService");
            GG.W = GetService("Workspace");
            GG.L = GetService("Lighting");
            GG.P = GetService("Players");
            GG.C = GetService("CoreGui");

            GG.selff = P.LocalPlayer;
            GG.PlayerScripts = WaitForChild(selff, "PlayerScripts", 999);
            GG.PSG = WaitForChild(selff, "PlayerGui", 999);
            GG.Cam = WaitForChild(W, "Camera", 999);
            GG.cmdm = selff:GetMouse();
            GG.Backpack = selff.Backpack;
            GG.selc = selff.Character;

            GG.Kick = function( text : string )
                return selff:Kick(text);
            end;

            GG.dist = function( position : Vector3 )
                return selff:DistanceFromCharacter(position);
            end;

            GG.Tp2 = function( pos : CFrame )
                selff.Character.HumanoidRootPart.CFrame = pos;
                return true;
            end;

            GG.HttpGet = function( url : string , bool : boolean )
                local Sources = nil;
                for i=1, 3 do
                    local OneRunCall, OneRunError = pcal(function()
                        Sources = game:HttpGet(url, bool or nil);
                    end);
                    if not OneRunCall then
                        if i >= 3 then
                            return Kick("Failed to HttpGet. Report this bug to TTJY via discord.");
                        end;
                    else
                        return Sources;
                    end; twait();
                end;
                return Sources;
            end;

            GG.EnCodeJ = function( obj : Instance )
                return HttpService:JSONEncode(obj);
            end;
            GG.DeCodeJ = function( obj : Instance )
                return HttpService:JSONDecode(obj);
            end;

            GG.loadstring2 = loadstring;
            GG.loadsource = function( source : string )
                local Returner = nil;
                for i=1, 3 do
                    local OneRunC, OneRunE = pcal(function()
                        Returner = loadstring2(source)();
                    end);
                    if OneRunC then
                        return Returner;
                    else
                        warn("[Flow] : loadsource_err : " .. OneRunE);
                    end; twait();
                end;
                return Returner;
            end;

            GG.setfps = function( number : number )
                return setfpscap(number);
            end;

            GG.SetCore = function( title : string , text : string , duration : number )
                return StarterGui:SetCore("SendNotification", {Title = title,
                    Text = text,
                    Duration = duration
                });
            end;

            GG.f3x = function()
                return loadsource(HttpGet("https://raw.githubusercontent.com/infyiff/backup/refs/heads/main/f3x.lua", true))();
            end;
            GG.dex = function()
                return loadsource(HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/dex.lua", true))();
            end;
            GG.rspy = function()
                return loadsource(HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/SimpleSpyV3/main.lua", true))();
            end;
            GG.alogger = function()
                return loadsource(HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/audiologger.lua", true))();
            end;
            GG.INFY = function()
                return loadsource(HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source", true))();
            end;

            GG.ApPos = function()
                return setc(tos(selff.Character.HumanoidRootPart.Position));
            end;
            GG.ApCF = function()
                return setc(tos(selff.Character.HumanoidRootPart.CFrame));
            end;
            GG.writePos = function()
                return writefile("Pos.txt", tos(selff.Character.HumanoidRootPart.Position))
            end;

            GG.NoMouse = function()
                UserInputService.MouseIconEnabled = false;
                return;
            end;

            GG.All_UI = function(a)
                for _, v in pir(GetDescendants(game)) do
                    if IsA(v, "BillboardGui") then
                        v:Destroy(true); 
                    end;
                    if IsA(v, "ScreenGui") then
                        v.Enabled = a; 
                    end;
                end;
                return;
            end;
            GG.self_UI = function(a)
                for _, v in pir(GetDescendants(selff)) do
                    if IsA(v, "BillboardGui") then
                        v:Destroy(true); 
                    end;
                    if IsA(v, "ScreenGui") then
                        v.Enabled = a; 
                    end;
                end;
                return;
            end;

            GG.SendChatTxt = function(a)
                return TextService.TextChannels.RBXSystem:DisplaySystemMessage(a);
                -- "[ Flow Script ] <font color='#00ff5e'>Script Load!</font>""
            end;

            GG.loadScriptFromCache = function( srcName : string , fileName : string , noload : boolean )
                local cacheFolder = "FlowXS";
                local versionFile = cacheFolder .. "Version.json";
                local cacheFile = cacheFolder .. "/" .. fileName;
    
                if ALLVersion == nil then
                    ALLVersion = {};
                end;
            
                if ALLVersion[fileName] == nil then
                    ALLVersion[fileName] = tos(tick());
                end;
            
                if tick() - ton(ALLVersion[fileName]) >= 600 then
                    local source = HttpGet(srcName, true);
                    writefile(cacheFile, source);
    
                    ALLVersion[fileName] = tos(tick());
    
                    local versionContent = EnCodeJ(ALLVersion);
                    writefile(versionFile, versionContent);
    
                    warn("[Flow] : Loaded " .. fileName .. " from GitHub via auto-update");
    
                    if noload then
                        return source
                    end;
                    return loadsource(source);
                else
                    if isfolder(cacheFolder) then
                        local cachedSource = isfile(cacheFile) and readfile(cacheFile);
    
                        if not cachedSource or not isfile(versionFile) then
                            local source = HttpGet(srcName, true);
                            writefile(cacheFile, source);
    
                            ALLVersion[fileName] = tos(tick());
                            local versionContent = EnCodeJ(ALLVersion);
    
                            writefile(versionFile, versionContent);
                            warn("[Flow] : Loaded " .. fileName .. " from GitHub");
    
                            if noload then
                                return source
                            end;
                            return loadsource(source);
                        else
                            warn("[Flow] : Loaded " .. fileName .. " from device and NOT GitHub");
        
                            if noload then
                                return source
                            end;
                            return loadsource(cachedSource);
                        end;
                    else
                        return Kick("isfolder check failed, try rejoining before reporting the bug");
                    end;
                end;
            end;

            GG.SecureStart = function()

                if GG.AlreadyDoSecureStart then
                    GG.LSecureLoad();
                    GG.DoyouWantToUseThis.ScreenGui.Enabled = true;
                    return;
                end;
            
                GG.AlreadyDoSecureStart = true;
            
                local blur = Instancen("BlurEffect", L);
                blur.Size = 100;
                blur.Enabled = true;
            
                local ScreenGui = Instancen("ScreenGui");
                ScreenGui.Parent = selff["PlayerGui"];
                ScreenGui.ResetOnSpawn = false;
                ScreenGui.DisplayOrder = 10;
                ScreenGui.IgnoreGuiInset = true;
            
                local BackgroundFrame = Instancen("Frame")
                BackgroundFrame.Size = UDim2.new(1, 0, 1, 0)
                BackgroundFrame.BackgroundTransparency = 0
                BackgroundFrame.Parent = ScreenGui
                local BackgroundGradient = Instancen("UIGradient")
                BackgroundGradient.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, Color3.fromRGB(20, 20, 60)),
                    ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 20, 100))
                })
                BackgroundGradient.Rotation = 45
                BackgroundGradient.Parent = BackgroundFrame
                BackgroundFrame.BackgroundTransparency = 0.1
            
                local OpeningLine = Instancen("Frame")
                OpeningLine.Size = UDim2.new(0, 0, 0, 3)
                OpeningLine.Position = UDim2.new(0, 0, 0.5, 0)
                OpeningLine.AnchorPoint = Vector2.new(0, 0.5)
                OpeningLine.BackgroundColor3 = Color3.fromRGB(200, 150, 255)
                OpeningLine.Parent = ScreenGui
            
                local FlowLabel = Instancen("TextLabel")
                FlowLabel.Size = UDim2.new(0.2, 0, 0.1, 0)
                FlowLabel.Position = UDim2.new(0.5, 0, 0.45, 0)
                FlowLabel.AnchorPoint = Vector2.new(0.5, 0.5)
                FlowLabel.BackgroundTransparency = 1
                FlowLabel.Text = "<b>Flow</b>"
                FlowLabel.RichText = true
                FlowLabel.Font = Enum.Font.SourceSansBold
                FlowLabel.TextSize = 40
                FlowLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                FlowLabel.TextTransparency = 1
                FlowLabel.Parent = ScreenGui
            
                local BoxTop = Instancen("Frame")
                BoxTop.Size = UDim2.new(0, 0, 0, 3)
                BoxTop.Position = UDim2.new(0.35, 0, 0.45, 0)
                BoxTop.BackgroundColor3 = Color3.fromRGB(200, 150, 255)
                BoxTop.Parent = ScreenGui
            
                local BoxTopGradient = Instancen("UIGradient")
                BoxTopGradient.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0),
                    NumberSequenceKeypoint.new(1, 0)
                })
                BoxTopGradient.Offset = Vector2.new(-1, 0)
                BoxTopGradient.Parent = BoxTop
            
                local BoxRight = Instancen("Frame")
                BoxRight.Size = UDim2.new(0, 3, 0, 0)
                BoxRight.Position = UDim2.new(0.65, 0, 0.45, 0)
                BoxRight.BackgroundColor3 = Color3.fromRGB(200, 150, 255)
                BoxRight.Parent = ScreenGui
            
                local BoxBottom = Instancen("Frame")
                BoxBottom.Size = UDim2.new(0, 0, 0, 3)
                BoxBottom.Position = UDim2.new(0.65, 0, 0.55, 0)
                BoxBottom.BackgroundColor3 = Color3.fromRGB(200, 150, 255)
                BoxBottom.Parent = ScreenGui
            
                local BoxLeft = Instancen("Frame")
                BoxLeft.Size = UDim2.new(0, 3, 0, 0)
                BoxLeft.Position = UDim2.new(0.35, 0, 0.55, 0)
                BoxLeft.BackgroundColor3 = Color3.fromRGB(200, 150, 255)
                BoxLeft.Parent = ScreenGui
            
                local WelcomeLabel = Instancen("TextLabel")
                WelcomeLabel.Size = UDim2.new(0.3, 0, 0.05, 0)
                WelcomeLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
                WelcomeLabel.BackgroundTransparency = 1
                WelcomeLabel.Text = "Welcome <font color='rgb(255,0,0)'>User!</font>"
                WelcomeLabel.RichText = true
                WelcomeLabel.Font = Enum.Font.SourceSansBold
                WelcomeLabel.TextSize = 30
                WelcomeLabel.AnchorPoint = Vector2.new(0.5,0.5)
                WelcomeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                WelcomeLabel.TextTransparency = 1
                WelcomeLabel.Parent = ScreenGui
            
                local PasswordBox = Instancen("TextBox")
                PasswordBox.Size = UDim2.new(0.2, 0, 0.05, 0)
                PasswordBox.Position = UDim2.new(0.5, 0, 0.6, 0)
                PasswordBox.Text = ""
                PasswordBox.PlaceholderText = "Password..."
                PasswordBox.Font = Enum.Font.SourceSans
                PasswordBox.TextSize = 20
                PasswordBox.TextColor3 = Color3.fromRGB(200, 200, 200)
                PasswordBox.TextTransparency = 1
                PasswordBox.BackgroundTransparency = 1
                PasswordBox.Parent = ScreenGui
                local PasswordGradient = Instancen("UIGradient")
                PasswordGradient.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 80)),
                    ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 60, 160))
                })
                PasswordGradient.Parent = PasswordBox
                local PasswordCorner = Instancen("UICorner")
                PasswordCorner.CornerRadius = UDim.new(0, 8)
                PasswordCorner.Parent = PasswordBox
                local PasswordStroke = Instancen("UIStroke")
                PasswordStroke.Thickness = 2
                PasswordStroke.Color = Color3.fromRGB(200, 150, 255)
                PasswordStroke.Transparency = 1
                PasswordStroke.Parent = PasswordBox
            
                local function animateOpeningLine()
                    local extend = TweenService:Create(OpeningLine, TweenInfo.new(0.5, Enum.EasingStyle.Linear), {
                        Size = UDim2.new(1, 0, 0, 3)
                    })
                    local fadeOut = TweenService:Create(OpeningLine, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {
                        BackgroundTransparency = 1
                    })
                    extend:Play()
                    task.wait(1.3)
                    fadeOut:Play()
                end
            
                local function animateFlow()
                    local fadeIn = TweenService:Create(FlowLabel, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {TextTransparency = 0})
                    local fadeOut = TweenService:Create(FlowLabel, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {TextTransparency = 1})
                    fadeIn:Play()
                    fadeIn.Completed:Connect(function()
                        wait(0.5)
                        fadeOut:Play()
                    end)
                end
            
                local a1, b1 = BoxTop.Position, BoxTop.Size;
                local a2, b2 = BoxRight.Position, BoxRight.Size;
                local a3, b3 = BoxBottom.Position, BoxBottom.Size;
                local a4, b4 = BoxLeft.Position, BoxLeft.Size;
            
                local function animateBox(i)
                    BoxTop.Position = a1
                    BoxTop.Size = b1
                    
                    BoxRight.Position = a2
                    BoxRight.Size = b2
                    
                    BoxBottom.Position = a3
                    BoxBottom.Size = b3
                    
                    BoxLeft.Position = a4
                    BoxLeft.Size = b4
            
                    local topTween = TweenService:Create(BoxTop, TweenInfo.new(0.2, Enum.EasingStyle.Linear), {
                        Size = UDim2.new(0.3, 0, 0, 3)
                    })
            
                    local topDisappearTween = TweenService:Create(BoxTop, TweenInfo.new(0.2, Enum.EasingStyle.Linear), {
                        Position = UDim2.new(BoxTop.Position.X.Scale + 0.3, BoxTop.Position.X.Offset, BoxTop.Position.Y.Scale, BoxTop.Position.Y.Offset),
                        Size = UDim2.new(0, 0, 0, 3)
                    })
            
                    local rightTween = TweenService:Create(BoxRight, TweenInfo.new(0.1, Enum.EasingStyle.Linear), {
                        Size = UDim2.new(0, 3, 0.1, 0)
                    })
            
                    local rightDisappearTween = TweenService:Create(BoxRight, TweenInfo.new(0.1, Enum.EasingStyle.Linear), {
                        Position = UDim2.new(BoxRight.Position.X.Scale, BoxRight.Position.X.Offset, BoxRight.Position.Y.Scale + 0.1, BoxRight.Position.Y.Offset),
                        Size = UDim2.new(0, 3, 0, 0)
                    })
            
                    local bottomTween = TweenService:Create(BoxBottom, TweenInfo.new(0.2, Enum.EasingStyle.Linear), {
                        Size = UDim2.new(-0.3, 0, 0, 3)
                    })
            
                    local bottomDisappearTween = TweenService:Create(BoxBottom, TweenInfo.new(0.2, Enum.EasingStyle.Linear), {
                        Position = UDim2.new(BoxBottom.Position.X.Scale - 0.3, BoxBottom.Position.X.Offset, BoxBottom.Position.Y.Scale, BoxBottom.Position.Y.Offset),
                        Size = UDim2.new(0, 0, 0, 3)
                    })
            
                    local leftTween = TweenService:Create(BoxLeft, TweenInfo.new(0.1, Enum.EasingStyle.Linear), {
                        Size = UDim2.new(0, 3, -0.1, 0)
                    })
            
                    local leftDisappearTween = TweenService:Create(BoxLeft, TweenInfo.new(0.1, Enum.EasingStyle.Linear), {
                        Position = UDim2.new(BoxLeft.Position.X.Scale, BoxLeft.Position.X.Offset, BoxLeft.Position.Y.Scale - 0.1, BoxLeft.Position.Y.Offset),
                        Size = UDim2.new(0, 3, 0, 0)
                    })
            
                    local fadeOutTop = TweenService:Create(BoxTop, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {BackgroundTransparency = 1})
                    local fadeOutRight = TweenService:Create(BoxRight, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {BackgroundTransparency = 1})
                    local fadeOutBottom = TweenService:Create(BoxBottom, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {BackgroundTransparency = 1})
                    local fadeOutLeft = TweenService:Create(BoxLeft, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {BackgroundTransparency = 1})
            
                    topTween:Play()
                    topTween.Completed:Connect(function()
                        rightTween:Play()
                        if i <= 3 then
                            topDisappearTween:Play() end;
                    end)
                    rightTween.Completed:Connect(function()
                        bottomTween:Play()
                        if i <= 3 then
                        rightDisappearTween:Play(); end;
                    end)
                    bottomTween.Completed:Connect(function()
                        leftTween:Play();
                        if i <= 3 then
                        bottomDisappearTween:Play(); end;
                    end)
                    leftTween.Completed:Connect(function()
                        if i <= 3 then
                        leftDisappearTween:Play(); end;
                    end)
                    if i <= 3 then
                    leftDisappearTween.Completed:Wait(); end;
            
                    if i > 3 then
                        return task.spawn(function()
                            task.wait(0.8);
                            fadeOutTop:Play()
                            fadeOutRight:Play()
                            fadeOutBottom:Play()
                            fadeOutLeft:Play()
                        end);
                    end;
            
                    return task.wait();
                end
            
                local function animateWelcome()
                    local fadeIn = TweenService:Create(WelcomeLabel, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {TextTransparency = 0})
                    local fadeOut = TweenService:Create(WelcomeLabel, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {TextTransparency = 1})
                    fadeIn:Play()
                    fadeIn.Completed:Connect(function()
                        task.wait(0.5)
                        fadeOut:Play()
                    end)
                end
            
                local function animatePassword()
                    local fadeBox = TweenService:Create(PasswordBox, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {TextTransparency = 0, BackgroundTransparency = 0})
                    local strokeBox = TweenService:Create(PasswordStroke, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {Transparency = 0})
                    fadeBox:Play()
                    strokeBox:Play()
                end
            
                animateFlow()
                animateOpeningLine()
                wait(2.1)
                for i=1, 4 do
                    if i == 2 then
                        task.spawn(function()
                            GG.LSecureLoad();
                        end);
                    end
                    animateBox(i)
                end;
                task.wait(0.5)
                animateWelcome()
                task.wait(2.1)
            
                --[[
                animatePassword()
            
                -- Handle password input: Destroy everything on Enter
                PasswordBox.FocusLost:Connect(function(enterPressed)
                    if enterPressed then
                        ScreenGui:Destroy()
                    end
                end)
            
                --]]
            
                BackgroundFrameANim = TweenService:Create(BackgroundFrame, TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
                BackgroundFrameANim:Play();
                BackgroundFrameANim.Completed:Wait(0.1);
                blur:Destroy(true)
                ScreenGui:Destroy(true);
            
                if GG and GG.DoyouWantToUseThis then
                    GG.DoyouWantToUseThis.ScreenGui.Enabled = true;
                end;
            end;

            GG.getCFrameAsString = function(cframe)
                return concat({cframe:GetComponents()},",");
            end;

            GG.getCFrameFromString = function(str)
                return CF(unpack(str:split(",")));
            end;

            GG.GetGradient = function( text : string , startColor : Color3 , endColor : Color3 ): string
                local result = "";
                local length = #text;

                for i = 1, length do
                    local t = (i - 1) / math.max(length - 1, 1)
                    local r = mfloor((startColor.R + (endColor.R - startColor.R) * t) * 255);
                    local g = mfloor((startColor.G + (endColor.G - startColor.G) * t) * 255);
                    local b = mfloor((startColor.B + (endColor.B - startColor.B) * t) * 255);

                    local char = text:sub(i, i)
                    result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>";
                end;

                return result;
            end;
            
            GG.CG_tbl_ToString = function(tbl, indentLevel)
                indentLevel = indentLevel or 0
                local indent = string.rep("    ", indentLevel)
                if type(tbl) ~= "table" then
                    if type(tbl) == "string" then
                        return "\"" .. tbl .. "\""
                    end
                    return tostring(tbl)
                end
            
                local result = "{\n"
                local isArray = true
                local length = 0
    
                for k, _ in pairs(tbl) do
                    if type(k) ~= "number" or k < 1 or math.floor(k) ~= k then
                        isArray = false
                    end
                    length = length + 1
                end
            
                if length == 0 then
                    return "{}"
                end
            
                if isArray then
                    local arrayLength = #tbl
                    for i = 1, arrayLength do
                        local value = tbl[i]
                        result = result .. indent .. "    "
                        if type(value) == "table" then
                            result = result .. CG_tbl_ToString(value, indentLevel + 1)
                        elseif type(value) == "string" then
                            result = result .. "\"" .. value .. "\""
                        else
                            result = result .. tos(value)
                        end
                        if i < arrayLength then
                            result = result .. ","
                        end
                        result = result .. "\n"
                    end
                else
                    local index = 0
                    for k, v in pairs(tbl) do
                        index = index + 1
                        result = result .. indent .. "    ["
                        if type(k) == "string" then
                            result = result .. "\"" .. k .. "\""
                        else
                            result = result .. tos(k)
                        end
                        result = result .. "] = "
                        if type(v) == "table" then
                            result = result .. CG_tbl_ToString(v, indentLevel + 1)
                        elseif type(v) == "string" then
                            result = result .. "\"" .. v .. "\""
                        else
                            result = result .. tos(v)
                        end
                        if index < length then
                            result = result .. ","
                        end
                        result = result .. "\n"
                    end
                end
            
                result = result .. indent .. "}";
                return result;
            end;

            function FProximityPrompt()
                local unc = {
                    Prompts = {};
                }
            
                local Camera = Cam;
                local Execonce = Instancen('Part');
            
                Execonce.Anchored = true;
                Execonce.CanTouch = false;
                Execonce.CanCollide = false;
                Execonce.CanQuery = false;
                Execonce.CastShadow = false;
                Execonce.Size = Vec3(0.01,0.01,0.01);
                Execonce.Parent = workspace;
                Execonce.Name = 'Regisiter';
                Execonce.Transparency = 1;
            
                function unc.fireprompt(ProximityPrompt, ...)
                    if not unc[ProximityPrompt] then
                        local Information = {};
                        
                        Information.HoldDuration = ProximityPrompt.HoldDuration;
                        Information.MaxActivationDistance = ProximityPrompt.MaxActivationDistance;
                        Information.RequiresLineOfSight = ProximityPrompt.RequiresLineOfSight;
                        Information.Parent = ProximityPrompt.Parent;
                        
                        unc[ProximityPrompt] = Information;
                    end;
                    
                    local Init = function()
                        
                    
                        Execonce.CFrame = Camera.CFrame * CF(0,0,-4);
                        
                        ProximityPrompt.HoldDuration = -5;
                        ProximityPrompt.MaxActivationDistance = 250;
                        ProximityPrompt.Enabled = true;
                        ProximityPrompt.RequiresLineOfSight = false;
                        ProximityPrompt.Parent = Execonce;
                        
                        local spam = task.spawn(function()
                            while true do 
                                twait(0.000001/9)
                                Execonce.CFrame = Camera.CFrame * CF(0,0,-4);
                                ProximityPrompt:InputHoldBegin();
                                
                                H.RenderStepped:Wait()
                                
                                Execonce.CFrame = Camera.CFrame * CF(0,0,-4);
                                ProximityPrompt:InputHoldEnd();
                            end;
                        end)
                        
                        ProximityPrompt.Triggered:Wait();
                        
                        repeat twait();
                            KAWKWDKDK, WDAJDUWAY2waWDW = pcal(function()
                                task.cancel(spam);
                            end);
                        until KAWKWDKDK
                        
                        local Loaded = unc[ProximityPrompt];
                        
                        ProximityPrompt.HoldDuration = Loaded.HoldDuration;
                        ProximityPrompt.MaxActivationDistance = Loaded.MaxActivationDistance;
                        ProximityPrompt.RequiresLineOfSight = Loaded.RequiresLineOfSight;
                        ProximityPrompt.Parent = Loaded.Parent;
                    end;
                    
                    local option = {...};
                    
                    if typeof(option[1]) == 'number' then
                        for i=1,option[1] do
                            Init();
                        end;
                    end;
                end;
            
                return unc
            end;

            if (GG.uncCheck2point1)["fireproximityprompt"] ~= "C" then
                GG.fireproximityprompt = FProximityPrompt().fireprompt;
            end;
        end);

        if GlobalOneRunCall then
            GG.AlreadyLoadMain = true;
            break;
        else
            if i == 3 then
                game:GetService("Players"):Kick("Please report this bug to discord server and provide your executor. : " .. GlobalOneRunError);
            end;
        end;
    end;
end;

GG.is_mobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled;
GG.CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0};

if isMobile and (GG.uncCheck2point1)["require"] ~= "Lua" then
    GG.controlModule = GG.controlModule or require(PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"));
end

if UpperC then
    if PlaceId == 15962819441 then
        local a = nil;
        a = UpperC(game, "__namecall", function(self, ...)
            local args = {...};
            local method = getnamecallmethod();
            local tos_self = tos(self);

            if method == "FireServer" then
                if tos_self == "Sender" or tos_self == "Sender2" then
                    return wait(9e9);
                end;
            end;

            return a(self, ...);
        end);
    end;
    if PlaceId == 96354063422506 then
        local ml = {
            GS = "GetService",
            jfoik = "Players",
            nIJM = "LocalPlayer",
            mhfd = "PlayerGui",
            j6yr = "ChildAdded",
            paosd = "game",
            mkas = "next",
            p0ms = "getconnections",
            nsjkd = 'Disable',
            X19uYW1lY2FsbA = "__namecall",
            X19pbmRleA = "__index",
            mksdsdds = "Bypassed Anti Cheat [sUNC + Specific]",
        };
        
        local k,osi = getfenv(),getgenv();
        local p = k[ml.paosd];
        local s = k[ml.mkas];
        local kd = osi[ml.p0ms];
        local meta = "ReplicatedFirst.Loading.LocalScript";
        
        for i,v in s , kd(p[ml.GS](p,ml.jfoik)[ml.nIJM][ml.mhfd][ml.j6yr]) do
            if v then
                v[ml.nsjkd](v);
            end;
        end;
        
        local old;
        old = UpperC(p,ml.X19uYW1lY2FsbA,function(self , ...)
            local traceBACK = debug.traceback();
        
            if string.find(traceBACK,meta,1,true) then
                return error(ml.mksdsdds);
            end;
        
            if getnamecallmethod() == "FireServer" and not checkcaller() then
                if string.find(tostring(self),"Sender",1,true) then
                    return error(ml.mksdsdds);
                end;
            end;
            return old(self , ...)
        end);
        
        local old_ind;
        old_ind = UpperC(p,ml.X19pbmRleA,function(self , i , v)
            local traceBACK = debug.traceback();
        
            if string.find(traceBACK,meta,1,true) then
                return error(ml.mksdsdds);
            end;
        
            if string.find(tostring(self),"Sender",1,true) and not checkcaller() then
                return error(ml.mksdsdds);
            end;
        
            return old_ind(self , i , v)
        end);
        
        do
            local oldfire;
            oldfire = LowerC(Instance.new("RemoteEvent").FireServer,function(self,...)
                local traceBACK = debug.traceback();
        
                if string.find(traceBACK,meta,1,true) then
                    return error(ml.mksdsdds);
                end;
        
                if string.find(tostring(self),"Sender",1,true) then
                    return error(ml.mksdsdds);
                end;
        
                return oldfire(self, ...)
            end);
        end;
        
        do
            local oldfire;
            oldfire = LowerC(Instance.new("UnreliableRemoteEvent").FireServer,function(self,...)
                local traceBACK = debug.traceback();
        
                if string.find(traceBACK,meta,1,true) then
                    return error(ml.mksdsdds);
                end;
        
                if string.find(tostring(self),"Sender",1,true) then
                    return error(ml.mksdsdds);
                end;
        
                return oldfire(self, ...)
            end);
        end;
    end;
end;

if not GG.GraphicsEditorLoad then
    GG.GraphicsEditorLoad = function( tab : editorTab ): any
        if not isfolder("FlowXS/GraphicsSave") then
            makefolder("FlowXS/GraphicsSave");
        end;
        if not isfolder("FlowXS/GraphicsSave/SurfaceL") then
            makefolder("FlowXS/GraphicsSave/SurfaceL");
        end;
        if not isfolder("FlowXS/GraphicsSave/PointL") then
            makefolder("FlowXS/GraphicsSave/PointL");
        end;
        if not isfolder("FlowXS/GraphicsSave/SpotL") then
            makefolder("FlowXS/GraphicsSave/SpotL");
        end;
        if not isfolder("FlowXS/GraphicsSave/MainGCC") then
            makefolder("FlowXS/GraphicsSave/MainGCC");
        end;
        
        local Files_SurfaceLightSaved = listfiles("FlowXS/GraphicsSave/SurfaceL");
        local Files_PointLightSaved = listfiles("FlowXS/GraphicsSave/PointL");
        local Files_SpotLightSaved = listfiles("FlowXS/GraphicsSave/SpotL");
        local Files_MainGCCSaved = listfiles("FlowXS/GraphicsSave/MainGCC");

        ScriptData["Sky_UnSave"] = {};
        ScriptData["Sky_UnSave"]["Sky_UnSave"] = ScriptData["Sky_UnSave"]["Sky_UnSave"] or {};

        ScriptData["Graphics"] = ScriptData["Graphics"] or {};
        ScriptData["Graphics"]["Sky"] = ScriptData["Graphics"]["Sky"] or {};
        ScriptData["Graphics"]["Atmosphere"] = ScriptData["Graphics"]["Atmosphere"] or {};
        ScriptData["Graphics"]["Blur"] = ScriptData["Graphics"]["Blur"] or {};
        ScriptData["Graphics"]["Bloom"] = ScriptData["Graphics"]["Bloom"] or {};
        ScriptData["Graphics"]["ColorCorrectionEffect"] = ScriptData["Graphics"]["ColorCorrectionEffect"] or {};
        ScriptData["Graphics"]["DepthOfFieldEffect"] = ScriptData["Graphics"]["DepthOfFieldEffect"] or {};
        ScriptData["Graphics"]["SunRaysEffect"] = ScriptData["Graphics"]["SunRaysEffect"] or {};
        ScriptData["Graphics"]["CS_SurfaceLight"] = ScriptData["Graphics"]["CS_SurfaceLight"] or {};
        ScriptData["Graphics"]["CS_SurfaceLight"]["MainObj"] = ScriptData["Graphics"]["CS_SurfaceLight"]["MainObj"] or {};
        ScriptData["Graphics"]["CS_PointLight"] = ScriptData["Graphics"]["CS_PointLight"] or {};
        ScriptData["Graphics"]["CS_PointLight"]["MainObj"] = ScriptData["Graphics"]["CS_PointLight"]["MainObj"] or {};
        ScriptData["Graphics"]["CS_SpotLight"] = ScriptData["Graphics"]["CS_SpotLight"] or {};
        ScriptData["Graphics"]["CS_SpotLight"]["MainObj"] = ScriptData["Graphics"]["CS_SpotLight"]["MainObj"] or {};

        local Sky = FindFirstChildWhichIsA(L, "Sky");
        local Atmosphere = FindFirstChildWhichIsA(L, "Atmosphere");
        local Blur = FindFirstChildWhichIsA(L, "BlurEffect");
        local Bloom = FindFirstChildWhichIsA(L, "BloomEffect");
        local ColorCorrection = FindFirstChildWhichIsA(L, "ColorCorrectionEffect");
        local DepthOfField = FindFirstChildWhichIsA(L, "DepthOfFieldEffect");
        local SunRaysEffect = FindFirstChildWhichIsA(L, "SunRaysEffect");
        local SuLightsFolder = FindFirstChild(W, "Made By TTJY - SU LI") or Instancen("Folder", W);
        local PLightsFolder = FindFirstChild(W, "Made By TTJY - P LI") or Instancen("Folder", W);
        local SPLightsFolder = FindFirstChild(W, "Made By TTJY - SP LI") or Instancen("Folder", W);

        SuLightsFolder.Name = "Made By TTJY - SU LI";
        PLightsFolder.Name = "Made By TTJY - P LI";
        SPLightsFolder.Name = "Made By TTJY - SP LI";

        local function MakeOneNoti( missing_obj : string ): any
            return DoyouWantToUseThis:Notify({
                Title = "<font color='rgb(255,255,0)'>WARNING</font>",
                Content = missing_obj .. " was not found. Please create one.",
                Icon = "circle-alert",
                Duration = 7,
            });
        end;

        tab:Section({ Title = "☁️ Sky ☁️", TextSize = 20 });
        tab:Dropdown({
            Title = "Select Skybox Spot",
            Values = {"Bk", "Dn", "Ft", "Lf", "Rt", "Up"},
            Value = ScriptData["Sky_UnSave"]["Sky_UnSave"]["SelectSkyBoxDirect"] or "Bk",
            Callback = function(option)  
                ScriptData["Sky_UnSave"]["Sky_UnSave"]["SelectSkyBoxDirect"] = "Skybox" .. option;
            end
        });
        tab:Input({
            Title = "rbxasset ID",
            Value = "6444320592",
            PlaceholderText = "Eneter ID",
            Callback = function(input) if not loaded then return; end; ScriptData["Sky_UnSave"]["Sky_UnSave"]["SkyboxID"] = "rbxassetid://" .. input; end
        });
        tab:Button({
            Title = "Apply Skybox",
            Callback = function()
                if not Sky or not Sky.Parent then return MakeOneNoti("Sky"); end;
                Sky[ScriptData["Sky_UnSave"]["Sky_UnSave"]["SelectSkyBoxDirect"]] = ScriptData["Sky_UnSave"]["Sky_UnSave"]["SkyboxID"];
            end
        });
        tab:Toggle({
            Title = "Celestial Bodies Shown",
            Value = (Sky and Sky["CelestialBodiesShown"]) or false,
            Callback = function(state)
                if not loaded then return; end;
                if not Sky or not Sky.Parent then return MakeOneNoti("Sky"); end;
                Sky["CelestialBodiesShown"] = state;
                ScriptData["Graphics"]["Sky"]["CelestialBodiesShown"] = state;
            end
        });
        tab:Input({
            Title = "Moon Angular Size",
            Value = (Sky and tos(Sky["MoonAngularSize"])) or "11",
            PlaceholderText = "Enter Size",
            Callback = function(input)
                if not loaded then return; end;
                if not Sky or not Sky.Parent then return MakeOneNoti("Sky"); end;
                ScriptData["Graphics"]["Sky"]["MoonAngularSize"] = ton(input);
                Sky["MoonAngularSize"] = ScriptData["Graphics"]["Sky"]["MoonAngularSize"];
            end
        });
        tab:Input({
            Title = "Sun Angular Size",
            Value = (Sky and tos(Sky["SunAngularSize"])) or "11",
            PlaceholderText = "Enter Size",
            Callback = function(input)
                if not loaded then return; end;
                if not Sky or not Sky.Parent then return MakeOneNoti("Sky"); end;
                ScriptData["Graphics"]["Sky"]["SunAngularSize"] = ton(input);
                Sky["SunAngularSize"] = ScriptData["Graphics"]["Sky"]["SunAngularSize"];
            end
        });
        tab:Input({
            Title = "Star Count",
            Value = (Sky and tos(Sky["StarCount"])) or "3000",
            PlaceholderText = "Enter Size",
            Callback = function(input)
                if not loaded then return; end;
                if not Sky or not Sky.Parent then return MakeOneNoti("Sky"); end;
                ScriptData["Graphics"]["Sky"]["StarCount"] = ton(input);
                Sky["StarCount"] = ScriptData["Graphics"]["Sky"]["StarCount"];
            end
        });

        tab:Section({ Title = "🌫️ Atmosphere 🌫️", TextSize = 20 });
        tab:Input({
            Title = "Color",
            Value = (Atmosphere and tos(Atmosphere["Color"])) or "",
            PlaceholderText = "?, ?, ?",
            Callback = function(input)
                if not loaded then return; end;
                if not Atmosphere or not Atmosphere.Parent then return MakeOneNoti("Atmosphere"); end;
                ScriptData["Graphics"]["Atmosphere"]["Color"] = "fromRGB(" .. input .. ")";
                Atmosphere["Color"] = loadstring("return " .. ScriptData["Graphics"]["Atmosphere"]["Color"])();
            end
        });
        tab:Input({
            Title = "Decay",
            Value = (Atmosphere and tos(Atmosphere["Decay"])) or "",
            PlaceholderText = "?, ?, ?",
            Callback = function(input)
                if not loaded then return; end;
                if not Atmosphere or not Atmosphere.Parent then return MakeOneNoti("Atmosphere"); end;
                ScriptData["Graphics"]["Atmosphere"]["Decay"] = "fromRGB(" .. input .. ")";
                Atmosphere["Decay"] = loadstring("return " .. ScriptData["Graphics"]["Atmosphere"]["Decay"])();
            end
        });
        tab:Input({
            Title = "Density",
            Value = (Atmosphere and tos(Atmosphere["Density"])) or "",
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not Atmosphere or not Atmosphere.Parent then return MakeOneNoti("Atmosphere"); end;
                ScriptData["Graphics"]["Atmosphere"]["Density"] = ton(input);
                Atmosphere["Density"] = ScriptData["Graphics"]["Atmosphere"]["Density"];
            end
        });
        tab:Input({
            Title = "Glare",
            Value = (Atmosphere and tos(Atmosphere["Glare"])) or "",
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not Atmosphere or not Atmosphere.Parent then return MakeOneNoti("Atmosphere"); end;
                ScriptData["Graphics"]["Atmosphere"]["Glare"] = ton(input);
                Atmosphere["Glare"] = ScriptData["Graphics"]["Atmosphere"]["Glare"];
            end
        });
        tab:Input({
            Title = "Haze",
            Value = (Atmosphere and tos(Atmosphere["Haze"])) or "",
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not Atmosphere or not Atmosphere.Parent then return MakeOneNoti("Atmosphere"); end;
                ScriptData["Graphics"]["Atmosphere"]["Haze"] = ton(input);
                Atmosphere["Haze"] = ScriptData["Graphics"]["Atmosphere"]["Haze"];
            end
        });
        tab:Input({
            Title = "Offset",
            Value = (Atmosphere and tos(Atmosphere["Offset"])) or "",
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not Atmosphere or not Atmosphere.Parent then return MakeOneNoti("Atmosphere"); end;
                ScriptData["Graphics"]["Atmosphere"]["Offset"] = ton(input);
                Atmosphere["Offset"] = ScriptData["Graphics"]["Atmosphere"]["Offset"];
            end
        });

        tab:Section({ Title = "🫵 Blur 🫵", TextSize = 20 });
        tab:Input({
            Title = "Size",
            Value = (Blur and tos(Blur["Size"])) or "",
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not Blur or not Blur.Parent then return MakeOneNoti("BlurEffect"); end;
                ScriptData["Graphics"]["Blur"]["Size"] = ton(input);
                Blur["Size"] = ScriptData["Graphics"]["Blur"]["Size"];
            end
        });

        tab:Section({ Title = "💡 Bloom Effect 💡", TextSize = 20 });
        tab:Input({
            Title = "Intensity",
            Value = (Bloom and tos(Bloom["Intensity"])) or "",
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not Bloom or not Bloom.Parent then return MakeOneNoti("BloomEffect"); end;
                ScriptData["Graphics"]["Bloom"]["Intensity"] = ton(input);
                Bloom["Intensity"] = ScriptData["Graphics"]["Bloom"]["Intensity"];
            end
        });
        tab:Input({
            Title = "Size",
            Value = (Bloom and tos(Bloom["Size"])) or "",
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not Bloom or not Bloom.Parent then return MakeOneNoti("BloomEffect"); end;
                ScriptData["Graphics"]["Bloom"]["Size"] = ton(input);
                Bloom["Size"] = ScriptData["Graphics"]["Bloom"]["Size"];
            end
        });
        tab:Input({
            Title = "Threshold",
            Value = (Bloom and tos(Bloom["Threshold"])) or "",
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not Bloom or not Bloom.Parent then return MakeOneNoti("BloomEffect"); end;
                ScriptData["Graphics"]["Bloom"]["Threshold"] = ton(input);
                Bloom["Threshold"] = ScriptData["Graphics"]["Bloom"]["Threshold"];
            end
        });

        tab:Section({ Title = "🌈 ColorCorrectionEffect 🌈", TextSize = 20 });
        tab:Input({
            Title = "Brightness",
            Value = (ColorCorrection and tos(ColorCorrection["Brightness"])) or nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not ColorCorrection or not ColorCorrection.Parent then return MakeOneNoti("ColorCorrectionEffect"); end;
                ScriptData["Graphics"]["ColorCorrectionEffect"]["Brightness"] = ton(input);
                ColorCorrection["Brightness"] = ScriptData["Graphics"]["ColorCorrectionEffect"]["Brightness"];
            end
        });
        tab:Input({
            Title = "Contrast",
            Value = (ColorCorrection and tos(ColorCorrection["Contrast"])) or nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not ColorCorrection or not ColorCorrection.Parent then return MakeOneNoti("ColorCorrectionEffect"); end;
                ScriptData["Graphics"]["ColorCorrectionEffect"]["Contrast"] = ton(input);
                ColorCorrection["Contrast"] = ScriptData["Graphics"]["ColorCorrectionEffect"]["Contrast"];
            end
        });
        tab:Input({
            Title = "Saturation",
            Value = (ColorCorrection and tos(ColorCorrection["Saturation"])) or nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not ColorCorrection or not ColorCorrection.Parent then return MakeOneNoti("ColorCorrectionEffect"); end;
                ScriptData["Graphics"]["ColorCorrectionEffect"]["Saturation"] = ton(input);
                ColorCorrection["Saturation"] = ScriptData["Graphics"]["ColorCorrectionEffect"]["Saturation"];
            end
        });
        tab:Input({
            Title = "TintColor",
            Value = (ColorCorrection and tos(ColorCorrection["TintColor"])) or nil,
            PlaceholderText = "?, ?, ?",
            Callback = function(input)
                if not loaded then return; end;
                if not ColorCorrection or not ColorCorrection.Parent then return MakeOneNoti("ColorCorrectionEffect"); end;
                ScriptData["Graphics"]["ColorCorrectionEffect"]["TintColor"] = "fromRGB(" .. input .. ")";
                ColorCorrection["TintColor"] = loadstring("return " .. ScriptData["Graphics"]["ColorCorrectionEffect"]["TintColor"])();
            end
        });
        tab:Toggle({
            Title = "Enabled",
            Value = (ColorCorrection and ColorCorrection["Enabled"]) or false,
            Callback = function(state)
                if not loaded then return; end;
                if not ColorCorrection or not ColorCorrection.Parent then return MakeOneNoti("ColorCorrectionEffect"); end;
                ColorCorrection["Enabled"] = state;
                ScriptData["Graphics"]["ColorCorrectionEffect"]["Enabled"] = state;
            end
        });

        tab:Section({ Title = "🔎 DepthOfFieldEffect 🔎", TextSize = 20 });
        tab:Input({
            Title = "FarIntensity",
            Value = (DepthOfField and tos(DepthOfField["FarIntensity"])) or nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end; 
                if not DepthOfField or not DepthOfField.Parent then return MakeOneNoti("DepthOfFieldEffect"); end;
                ScriptData["Graphics"]["DepthOfFieldEffect"]["FarIntensity"] = ton(input);
                DepthOfField["FarIntensity"] = ScriptData["Graphics"]["DepthOfFieldEffect"]["FarIntensity"];
            end
        });
        tab:Input({
            Title = "FocusDistance",
            Value = (DepthOfField and tos(DepthOfField["FocusDistance"])) or nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not DepthOfField or not DepthOfField.Parent then return MakeOneNoti("DepthOfFieldEffect"); end;
                ScriptData["Graphics"]["DepthOfFieldEffect"]["FocusDistance"] = ton(input);
                DepthOfField["FocusDistance"] = ScriptData["Graphics"]["DepthOfFieldEffect"]["FocusDistance"];
            end
        });
        tab:Input({
            Title = "InFocusRadius",
            Value = (DepthOfField and tos(DepthOfField["InFocusRadius"])) or nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not DepthOfField or not DepthOfField.Parent then return MakeOneNoti("DepthOfFieldEffect"); end;
                ScriptData["Graphics"]["DepthOfFieldEffect"]["InFocusRadius"] = ton(input);
                DepthOfField["InFocusRadius"] = ScriptData["Graphics"]["DepthOfFieldEffect"]["InFocusRadius"];
            end
        });
        tab:Input({
            Title = "NearIntensity",
            Value = (DepthOfField and tos(DepthOfField["NearIntensity"])) or nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not DepthOfField or not DepthOfField.Parent then return MakeOneNoti("DepthOfFieldEffect"); end;
                ScriptData["Graphics"]["DepthOfFieldEffect"]["NearIntensity"] = ton(input);
                DepthOfField["NearIntensity"] = ScriptData["Graphics"]["DepthOfFieldEffect"]["NearIntensity"];
            end
        });
        tab:Toggle({
            Title = "Enabled",
            Value = (DepthOfField and DepthOfField["Enabled"]) or false,
            Callback = function(state)
                if not loaded then return; end;
                if not DepthOfField or not DepthOfField.Parent then return MakeOneNoti("DepthOfFieldEffect"); end;
                DepthOfField["Enabled"] = state;
                ScriptData["Graphics"]["DepthOfFieldEffect"]["Enabled"] = state;
            end
        });

        tab:Section({ Title = "☀️ Sun Rays ☀️", TextSize = 20 });
        tab:Input({
            Title = "Intensity",
            Value = (SunRaysEffect and tos(SunRaysEffect["Intensity"])) or nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not SunRaysEffect or not SunRaysEffect.Parent then return MakeOneNoti("SunRaysEffect"); end;
                ScriptData["Graphics"]["SunRaysEffect"]["Intensity"] = ton(input);
                SunRaysEffect["Intensity"] = ScriptData["Graphics"]["SunRaysEffect"]["Intensity"];
            end
        });
        tab:Input({
            Title = "Spread",
            Value = (SunRaysEffect and tos(SunRaysEffect["Spread"])) or nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                if not SunRaysEffect or not SunRaysEffect.Parent then return MakeOneNoti("SunRaysEffect"); end;
                ScriptData["Graphics"]["SunRaysEffect"]["Spread"] = ton(input);
                SunRaysEffect["Spread"] = ScriptData["Graphics"]["SunRaysEffect"]["Spread"];
            end
        });
        tab:Toggle({
            Title = "Enabled",
            Value = (SunRaysEffect and SunRaysEffect["Enabled"]) or false,
            Callback = function(state)
                if not loaded then return; end;
                if not SunRaysEffect or not SunRaysEffect.Parent then return MakeOneNoti("SunRaysEffect"); end;
                SunRaysEffect["Enabled"] = state;
                ScriptData["Graphics"]["SunRaysEffect"]["Enabled"] = state;
            end
        });

        tab:Section({ Title = "💡 Custom SurfaceLight 💡", TextSize = 20 });
        SuLightsFolderObjectDrop = tab:Dropdown({
            Title = "Select Object",
            Values = (SuLightsFolder and function()
                local names = {};
                for _, child in ipairs(GetChildren(SuLightsFolder)) do
                    tablein(names, child.Name);
                end
                return names;
            end or function()
                return {};
            end)(),
            Value = ScriptData["Graphics"]["CS_SurfaceLight"]["Objects"] or {},
            Multi = true,
            Callback = function(option)
                ScriptData["Graphics"]["CS_SurfaceLight"]["Objects"] = option;
            end
        });
        tab:Button({
            Title = "Fetch Object",
            Callback = function()
                SuLightsFolderObjectDrop:Refresh((SuLightsFolder and function()
                    local names = {};
                    for _, child in ipairs(GetChildren(SuLightsFolder)) do
                        tablein(names, child.Name);
                    end
                    return names;
                end or function()
                    return {};
                end)());
            end
        });
        tab:Input({
            Title = "Color",
            Value = nil,
            PlaceholderText = "?, ?, ?",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["Graphics"]["CS_SurfaceLight"]["SelectedColor"] = "fromRGB(" .. input ..")";
                local SelectDataNow = ScriptData["Graphics"]["CS_SurfaceLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SuLightsFolder)) do
                        if obj.Name == v then 
                            obj["SurfaceLight"].Color = loadstring("return " .. ScriptData["Graphics"]["CS_SurfaceLight"]["SelectedColor"])();
                            ScriptData["Graphics"]["CS_SurfaceLight"]["MainObj"][obj.Name]["Color"] = ScriptData["Graphics"]["CS_SurfaceLight"]["SelectedColor"];
                        end;
                    end;
                end;
            end
        });
        tab:Input({
            Title = "Brightness",
            Value = nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["Graphics"]["CS_SurfaceLight"]["SelectedBrightness"] = input;
                local SelectDataNow = ScriptData["Graphics"]["CS_SurfaceLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SuLightsFolder)) do
                        if obj.Name == v then 
                            obj["SurfaceLight"].Brightness = ton(input);
                            ScriptData["Graphics"]["CS_SurfaceLight"]["MainObj"][obj.Name]["Brightness"] = ton(input);
                        end;
                    end;
                end;
            end
        });
        tab:Input({
            Title = "Angle",
            Value = nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["Graphics"]["CS_SurfaceLight"]["SelectedAngle"] = input;
                local SelectDataNow = ScriptData["Graphics"]["CS_SurfaceLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SuLightsFolder)) do
                        if obj.Name == v then 
                            obj["SurfaceLight"].Angle = ton(input);
                            ScriptData["Graphics"]["CS_SurfaceLight"]["MainObj"][obj.Name]["Angle"] = ton(input);
                        end;
                    end;
                end;
            end
        });
        tab:Input({
            Title = "Range",
            Value = nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["Graphics"]["CS_SurfaceLight"]["SelectedRange"] = input;
                local SelectDataNow = ScriptData["Graphics"]["CS_SurfaceLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SuLightsFolder)) do
                        if obj.Name == v then 
                            obj["SurfaceLight"].Range = ton(input);
                            ScriptData["Graphics"]["CS_SurfaceLight"]["MainObj"][obj.Name]["Range"] = ton(input);
                        end;
                    end;
                end;
            end
        });
        tab:Toggle({
            Title = "Shadows",
            Value = false,
            Callback = function(state)
                if not loaded then return end;
                local SelectDataNow = ScriptData["Graphics"]["CS_SurfaceLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SuLightsFolder)) do
                        if obj.Name == v then 
                            obj["SurfaceLight"].Shadows = state;
                            ScriptData["Graphics"]["CS_SurfaceLight"]["MainObj"][obj.Name]["Shadows"] = state;
                        end;
                    end;
                end;
            end
        });
        tab:Toggle({
            Title = "Enabled",
            Value = false,
            Callback = function(state)
                if not loaded then return end;
                local SelectDataNow = ScriptData["Graphics"]["CS_SurfaceLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SuLightsFolder)) do
                        if obj.Name == v then 
                            obj["SurfaceLight"].Enabled = state;
                            ScriptData["Graphics"]["CS_SurfaceLight"]["MainObj"][obj.Name]["Enabled"] = state;
                        end;
                    end;
                end;
            end
        });
        tab:Input({
            Title = "Name for new one",
            Value = nil,
            PlaceholderText = "...",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["SelectObject_GCC_Graphics2Name_SurfL"] = input;
            end
        });
        tab:Button({
            Title = "Create Surface Light",
            Callback = function()
                local Part = Instancen("Part", SuLightsFolder);
                Part.Name = ScriptData["SelectObject_GCC_Graphics2Name_SurfL"];
                Part.Massless = true;
                Part.CanTouch = false;
                Part.CanCollide = false;
                Part.CanQuery = false;
                local SurfaceLight = Instancen("SurfaceLight", Part);
                SurfaceLight.Name = "SurfaceLight";
                Part.Anchored = true;
                Part.CFrame = selff.Character.HumanoidRootPart.CFrame;
                ScriptData["Graphics"]["CS_SurfaceLight"]["MainObj"][Part.Name] = {
                    ["CF"] = getCFrameAsString(Part.CFrame);
                };
            end
        });
        tab:Input({
            Title = "All Debug Part Transparency",
            Value = nil,
            PlaceholderText = "0 or 1",
            Callback = function(input)
                if not loaded then return end;
                for _, child in pir(GetChildren(SuLightsFolder)) do
                    child.Transparency = ton(input);
                end
            end
        });
        SuLightsFolderSaveDrop = tab:Dropdown({
            Title = "Select Saved",
            Values = (function()
                local f_names = {};
                for _,v in pir(Files_SurfaceLightSaved) do
                    local fileName = v:match("([^/]+)%.json$");
                    if fileName then
                        tablein(f_names, fileName);
                    end;
                end;
                return f_names;
            end)(),
            Value = "None",
            Callback = function(option)  
                ScriptData["SelectObject_GCC_Graphics2_SurfaceSave"] = option;
            end
        });
        tab:Button({
            Title = "Fetch Saved List",
            Callback = function()
                SuLightsFolderSaveDrop:Refresh((function()
                    local f_names = {};
                    Files_SurfaceLightSaved = listfiles("FlowXS/GraphicsSave/SurfaceL");
                    for _,v in pir(Files_SurfaceLightSaved) do
                        local fileName = v:match("([^/]+)%.json$");
                        if fileName then
                            tablein(f_names, fileName);
                        end;
                    end;
                    return f_names;
                end)());
            end
        });
        tab:Button({
            Title = "Load Saved",
            Callback = function()
                local Configsav = DeCodeJ(readfile("FlowXS/GraphicsSave/SurfaceL/" .. ScriptData["SelectObject_GCC_Graphics2_SurfaceSave"] .. ".json"));
                for name, infos in pir(Configsav["CS_SurfaceLight"]["MainObj"]) do
                    local Part = Instancen("Part", SuLightsFolder);
                    Part.Name = name;
                    local SurfaceLight = Instancen("SurfaceLight", Part);
                    SurfaceLight.Name = "SurfaceLight";
                    Part.Anchored = true;
                    Part.Massless = true;
                    Part.CanTouch = false;
                    Part.CanCollide = false;
                    Part.CanQuery = false;
                    for i, v in pir(infos) do
                        pcal(function()
                            Part[i] = v;
                        end);
                        pcal(function()
                            SurfaceLight[i] = v;
                        end);
                    end;
                    Part["CFrame"] = getCFrameFromString(infos["CF"]);
                    if infos["Color"] then
                        SurfaceLight.Color = loadstring("return " .. infos["Color"])();
                    end;
                    ScriptData["Graphics"]["CS_SurfaceLight"]["MainObj"][tos(name)] = infos;
                end;
            end
        });
        tab:Button({
            Title = "Save to file",
            Callback = function()
                writefile("FlowXS/GraphicsSave/SurfaceL/a.json", EnCodeJ(ScriptData["Graphics"]));
            end
        });

        tab:Section({ Title = "💡 Custom PointLight 💡", TextSize = 20 });
        PLightsFolderObjectDrop = tab:Dropdown({
            Title = "Select Object",
            Values = (PLightsFolder and function()
                local names = {};
                for _, child in ipairs(GetChildren(PLightsFolder)) do
                    tablein(names, child.Name);
                end
                return names;
            end or function()
                return {};
            end)(),
            Value = ScriptData["Graphics"]["CS_PointLight"]["Objects"] or {},
            Multi = true,
            Callback = function(option)  
                ScriptData["Graphics"]["CS_PointLight"]["Objects"] = option;
            end
        });
        tab:Button({
            Title = "Fetch Object",
            Callback = function()
                PLightsFolderObjectDrop:Refresh((PLightsFolder and function()
                    local names = {};
                    for _, child in ipairs(GetChildren(PLightsFolder)) do
                        tablein(names, child.Name);
                    end
                    return names;
                end or function()
                    return {};
                end)());
            end
        });
        tab:Input({
            Title = "Color",
            Value = nil,
            PlaceholderText = "?, ?, ?",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["Graphics"]["CS_PointLight"]["SelectedColor"] = "fromRGB(" .. input ..")";
                local SelectDataNow = ScriptData["Graphics"]["CS_PointLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(PLightsFolder)) do
                        if obj.Name == v then 
                            obj["PointLight"].Color = loadstring("return " .. ScriptData["Graphics"]["CS_PointLight"]["SelectedColor"])();
                            ScriptData["Graphics"]["CS_PointLight"]["MainObj"][obj.Name]["Color"] = ScriptData["Graphics"]["CS_PointLight"]["SelectedColor"];
                        end;
                    end;
                end;
            end
        });
        tab:Input({
            Title = "Brightness",
            Value = nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["Graphics"]["CS_PointLight"]["SelectedBrightness"] = input;
                local SelectDataNow = ScriptData["Graphics"]["CS_PointLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(PLightsFolder)) do
                        if obj.Name == v then 
                            obj["PointLight"].Brightness = ton(input);
                            ScriptData["Graphics"]["CS_PointLight"]["MainObj"][obj.Name]["Brightness"] = ton(input);
                        end;
                    end;
                end;
            end
        });
        tab:Input({
            Title = "Range",
            Value = nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["Graphics"]["CS_PointLight"]["SelectedRange"] = input;
                local SelectDataNow = ScriptData["Graphics"]["CS_PointLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(PLightsFolder)) do
                        if obj.Name == v then 
                            obj["PointLight"].Range = ton(input);
                            ScriptData["Graphics"]["CS_PointLight"]["MainObj"][obj.Name]["Range"] = ton(input);
                        end;
                    end;
                end;
            end
        });
        tab:Toggle({
            Title = "Shadows",
            Value = false,
            Callback = function(state)
                if not loaded then return end;
                local SelectDataNow = ScriptData["Graphics"]["CS_PointLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(PLightsFolder)) do
                        if obj.Name == v then 
                            obj["PointLight"].Shadows = state;
                            ScriptData["Graphics"]["CS_PointLight"]["MainObj"][obj.Name]["Shadows"] = state;
                        end;
                    end;
                end;
            end
        });
        tab:Toggle({
            Title = "Enabled",
            Value = false,
            Callback = function(state)
                if not loaded then return end;
                local SelectDataNow = ScriptData["Graphics"]["CS_PointLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(PLightsFolder)) do
                        if obj.Name == v then 
                            obj["PointLight"].Enabled = state;
                            ScriptData["Graphics"]["CS_PointLight"]["MainObj"][obj.Name]["Enabled"] = state;
                        end;
                    end;
                end;
            end
        });
        tab:Input({
            Title = "Name for new one",
            Value = nil,
            PlaceholderText = "...",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["SelectObject_GCC_Graphics2Name_PoinL"] = input;
            end
        });
        tab:Button({
            Title = "Create Surface Light",
            Callback = function()
                local Part = Instancen("Part", PLightsFolder);
                Part.Name = ScriptData["SelectObject_GCC_Graphics2Name_PoinL"];
                Part.Massless = true;
                Part.CanTouch = false;
                Part.CanCollide = false;
                Part.CanQuery = false;
                local PointLight = Instancen("PointLight", Part);
                PointLight.Name = "PointLight";
                Part.Anchored = true;
                Part.CFrame = selff.Character.HumanoidRootPart.CFrame;
                ScriptData["Graphics"]["CS_PointLight"]["MainObj"][Part.Name] = {
                    ["CF"] = getCFrameAsString(Part.CFrame);
                };
            end
        });
        tab:Input({
            Title = "All Debug Part Transparency",
            Value = nil,
            PlaceholderText = "0 or 1",
            Callback = function(input)
                if not loaded then return end;
                for _, child in pir(GetChildren(PLightsFolder)) do
                    child.Transparency = ton(input);
                end
            end
        });
        PLightsFolderSaveDrop = tab:Dropdown({
            Title = "Select Saved",
            Values = (function()
                local f_names = {};
                for _,v in pir(Files_PointLightSaved) do
                    local fileName = v:match("([^/]+)%.json$");
                    if fileName then
                        tablein(f_names, fileName);
                    end;
                end;
                return f_names;
            end)(),
            Value = "None",
            Callback = function(option)  
                ScriptData["SelectObject_GCC_Graphics2_PSave"] = option;
            end
        });
        tab:Button({
            Title = "Fetch Saved List",
            Callback = function()
                PLightsFolderSaveDrop:Refresh((function()
                    local f_names = {};
                    Files_PointLightSaved = listfiles("FlowXS/GraphicsSave/PointL");
                    for _,v in pir(Files_PointLightSaved) do
                        local fileName = v:match("([^/]+)%.json$");
                        if fileName then
                            tablein(f_names, fileName);
                        end;
                    end;
                    return f_names;
                end)());
            end
        });
        tab:Button({
            Title = "Load Saved",
            Callback = function()
                local Configsav = DeCodeJ(readfile("FlowXS/GraphicsSave/PointL/" .. ScriptData["SelectObject_GCC_Graphics2_PSave"] .. ".json"));
                for name, infos in pir(Configsav["CS_PointLight"]["MainObj"]) do
                    local Part = Instancen("Part", PLightsFolder);
                    Part.Name = name;
                    local PointLight = Instancen("PointLight", Part);
                    PointLight.Name = "PointLight";
                    Part.Anchored = true;
                    Part.Massless = true;
                    Part.CanTouch = false;
                    Part.CanCollide = false;
                    Part.CanQuery = false;
                    for i, v in pir(infos) do
                        pcal(function()
                            Part[i] = v;
                        end);
                        pcal(function()
                            PointLight[i] = v;
                        end);
                    end;
                    Part["CFrame"] = getCFrameFromString(infos["CF"]);
                    if infos["Color"] then
                        PointLight.Color = loadstring("return " .. infos["Color"])();
                    end;
                    ScriptData["Graphics"]["CS_PointLight"]["MainObj"][tos(name)] = infos;
                end;
            end
        });
        tab:Button({
            Title = "Save to file",
            Callback = function()
                writefile("FlowXS/GraphicsSave/PointL/a.json", EnCodeJ(ScriptData["Graphics"]));
            end
        });

        tab:Section({ Title = "💡 Custom SpotLight 💡", TextSize = 20 });
        SPLightsFolderObjectDrop = tab:Dropdown({
            Title = "Select Object",
            Values = (SPLightsFolder and function()
                local names = {};
                for _, child in ipairs(GetChildren(SPLightsFolder)) do
                    tablein(names, child.Name);
                end
                return names;
            end or function()
                return {};
            end)(),
            Value = ScriptData["Graphics"]["CS_SpotLight"]["Objects"] or {},
            Multi = true,
            Callback = function(option)  
                ScriptData["Graphics"]["CS_SpotLight"]["Objects"] = option;
            end
        });
        tab:Button({
            Title = "Fetch Object",
            Callback = function()
                SPLightsFolderObjectDrop:Refresh((SPLightsFolder and function()
                    local names = {};
                    for _, child in ipairs(GetChildren(SPLightsFolder)) do
                        tablein(names, child.Name);
                    end
                    return names;
                end or function()
                    return {};
                end)());
            end
        });
        tab:Input({
            Title = "Color",
            Value = nil,
            PlaceholderText = "?, ?, ?",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["Graphics"]["CS_SpotLight"]["SelectedColor"] = "fromRGB(" .. input ..")";
                local SelectDataNow = ScriptData["Graphics"]["CS_SpotLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SPLightsFolder)) do
                        if obj.Name == v then 
                            obj["SpotLight"].Color = loadstring("return " .. ScriptData["Graphics"]["CS_SpotLight"]["SelectedColor"])();
                            ScriptData["Graphics"]["CS_SpotLight"]["MainObj"][obj.Name]["Color"] = ScriptData["Graphics"]["CS_SpotLight"]["SelectedColor"];
                        end;
                    end;
                end;
            end
        });
        tab:Input({
            Title = "Brightness",
            Value = nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["Graphics"]["CS_SpotLight"]["SelectedBrightness"] = input;
                local SelectDataNow = ScriptData["Graphics"]["CS_SpotLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SPLightsFolder)) do
                        if obj.Name == v then 
                            obj["SpotLight"].Brightness = ton(input);
                            ScriptData["Graphics"]["CS_SpotLight"]["MainObj"][obj.Name]["Brightness"] = ton(input);
                        end;
                    end;
                end;
            end
        });
        tab:Input({
            Title = "Range",
            Value = nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["Graphics"]["CS_SpotLight"]["SelectedRange"] = input;
                local SelectDataNow = ScriptData["Graphics"]["CS_SpotLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SPLightsFolder)) do
                        if obj.Name == v then 
                            obj["SpotLight"].Range = ton(input);
                            ScriptData["Graphics"]["CS_SpotLight"]["MainObj"][obj.Name]["Range"] = ton(input);
                        end;
                    end;
                end;
            end
        });
        tab:Input({
            Title = "Angle",
            Value = nil,
            PlaceholderText = "number...",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["Graphics"]["CS_SpotLight"]["SelectedAngle"] = input;
                local SelectDataNow = ScriptData["Graphics"]["CS_SpotLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SPLightsFolder)) do
                        if obj.Name == v then 
                            obj["SpotLight"].Angle = ton(input);
                            ScriptData["Graphics"]["CS_SpotLight"]["MainObj"][obj.Name]["Angle"] = ton(input);
                        end;
                    end;
                end;
            end
        });
        tab:Toggle({
            Title = "Shadows",
            Value = false,
            Callback = function(state)
                if not loaded then return end;
                local SelectDataNow = ScriptData["Graphics"]["CS_SpotLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SPLightsFolder)) do
                        if obj.Name == v then 
                            obj["SpotLight"].Shadows = state;
                            ScriptData["Graphics"]["CS_SpotLight"]["MainObj"][obj.Name]["Shadows"] = state;
                        end;
                    end;
                end;
            end
        });
        tab:Toggle({
            Title = "Enabled",
            Value = false,
            Callback = function(state)
                if not loaded then return end;
                local SelectDataNow = ScriptData["Graphics"]["CS_SpotLight"]["Objects"];
                for _,v in pir(SelectDataNow) do
                    for _,obj in pir(GetChildren(SPLightsFolder)) do
                        if obj.Name == v then 
                            obj["SpotLight"].Enabled = state;
                            ScriptData["Graphics"]["CS_SpotLight"]["MainObj"][obj.Name]["Enabled"] = state;
                        end;
                    end;
                end;
            end
        });
        tab:Input({
            Title = "Name for new one",
            Value = nil,
            PlaceholderText = "...",
            Callback = function(input)
                if not loaded then return; end;
                ScriptData["SelectObject_GCC_Graphics2Name_SpotL"] = input;
            end
        });
        tab:Button({
            Title = "Create Surface Light",
            Callback = function()
                local Part = Instancen("Part", SPLightsFolder);
                Part.Name = ScriptData["SelectObject_GCC_Graphics2Name_SpotL"];
                Part.Massless = true;
                Part.CanTouch = false;
                Part.CanCollide = false;
                Part.CanQuery = false;
                local SpotLight = Instancen("SpotLight", Part);
                SpotLight.Name = "SpotLight";
                Part.Anchored = true;
                Part.CFrame = selff.Character.HumanoidRootPart.CFrame;
                ScriptData["Graphics"]["CS_SpotLight"]["MainObj"][Part.Name] = {
                    ["CF"] = getCFrameAsString(Part.CFrame);
                };
            end
        });
        SPLightsFolderSaveDrop = tab:Dropdown({
            Title = "Select Saved",
            Values = (function()
                local f_names = {};
                for _,v in pir(Files_SpotLightSaved) do
                    local fileName = v:match("([^/]+)%.json$");
                    if fileName then
                        tablein(f_names, fileName);
                    end;
                end;
                return f_names;
            end)(),
            Value = "None",
            Callback = function(option)  
                ScriptData["SelectObject_GCC_Graphics2_SpotSave"] = option;
            end
        });
        tab:Button({
            Title = "Fetch Saved List",
            Callback = function()
                SPLightsFolderSaveDrop:Refresh((function()
                    local f_names = {};
                    Files_SpotLightSaved = listfiles("FlowXS/GraphicsSave/SpotL");
                    for _,v in pir(Files_SpotLightSaved) do
                        local fileName = v:match("([^/]+)%.json$");
                        if fileName then
                            print(fileName);
                            tablein(f_names, fileName);
                        end;
                    end;
                    return f_names;
                end)());
            end
        });
        tab:Button({
            Title = "Load Saved",
            Callback = function()
                local Configsav = DeCodeJ(readfile("FlowXS/GraphicsSave/SpotL/" .. ScriptData["SelectObject_GCC_Graphics2_SpotSave"] .. ".json"));
                for name, infos in pir(Configsav["CS_SpotLight"]["MainObj"]) do
                    local Part = Instancen("Part", SPLightsFolder);
                    Part.Name = name;
                    local SpotLight = Instancen("SpotLight", Part);
                    SpotLight.Name = "SpotLight";
                    Part.Anchored = true;
                    Part.Massless = true;
                    Part.CanTouch = false;
                    Part.CanCollide = false;
                    Part.CanQuery = false;
                    for i, v in pir(infos) do
                        pcal(function()
                            Part[i] = v;
                        end);
                        pcal(function()
                            SpotLight[i] = v;
                        end);
                    end;
                    Part["CFrame"] = getCFrameFromString(infos["CF"]);
                    if infos["Color"] then
                        SpotLight.Color = loadstring("return " .. infos["Color"])();
                    end;
                    ScriptData["Graphics"]["CS_SpotLight"]["MainObj"][tos(name)] = infos;
                end;
            end
        });
        tab:Button({
            Title = "Save to file",
            Callback = function()
                writefile("FlowXS/GraphicsSave/SpotL/a.json", EnCodeJ(ScriptData["Graphics"]));
            end
        });

        tab:Section({ Title = "🔨 Create/Make Object 🔨", TextSize = 20 });
        tab:Dropdown({
            Title = "Select Object",
            Values = {"Sky", "Atmosphere", "BlurEffect", "BloomEffect", "ColorCorrectionEffect", "DepthOfFieldEffect", "SunRaysEffect"},
            Value = ScriptData["Sky_UnSave"]["Sky_UnSave"]["SelectSkyBoxDirect"] or "Bk",
            Callback = function(option)  
                ScriptData["SelectObject_GCC_Graphics2"] = option;
            end
        });
        tab:Button({
            Title = "Build",
            Callback = function()
                if not loaded then return; end;
                local selected = ScriptData["SelectObject_GCC_Graphics2"];
                local a2 = Instancen(selected, L)
        
                if selected == "Sky" then
                    Sky = a2
                elseif selected == "Atmosphere" then
                    Atmosphere = a2;
                elseif selected == "BlurEffect" then
                    Blur = a2;
                elseif selected == "BloomEffect" then
                    Bloom = a2;
                elseif selected == "ColorCorrectionEffect" then
                    ColorCorrection = a2;
                elseif selected == "DepthOfFieldEffect" then
                    DepthOfField = a2;
                elseif selected == "SunRaysEffect" then
                    SunRaysEffect = a2;
                end
            end
        });

        tab:Section({ Title = "🔨 Import/Export Graphics 🔨", TextSize = 20 });
        SPLightsFolderSaveDrop = tab:Dropdown({
            Title = "Select Saved",
            Values = (function()
                local f_names = {};
                for _,v in pir(Files_MainGCCSaved) do
                    local fileName = v:match("([^/]+)%.json$");
                    if fileName then
                        tablein(f_names, fileName);
                    end;
                end;
                return f_names;
            end)(),
            Value = "None",
            Callback = function(option)  
                ScriptData["SelectObject_GCC_Graphics2_GCCSave"] = option;
            end
        });
        tab:Button({
            Title = "Fetch Saved List",
            Callback = function()
                SPLightsFolderSaveDrop:Refresh((function()
                    local f_names = {};
                    Files_MainGCCSaved = listfiles("FlowXS/GraphicsSave/MainGCC");
                    for _,v in pir(Files_MainGCCSaved) do
                        local fileName = v:match("([^/]+)%.json$");
                        if fileName then
                            tablein(f_names, fileName);
                        end;
                    end;
                    return f_names;
                end)());
            end
        });
        tab:Button({
            Title = "Load Saved",
            Callback = function()
                local Configsav = DeCodeJ(readfile("FlowXS/GraphicsSave/MainGCC/" .. ScriptData["SelectObject_GCC_Graphics2_GCCSave"] .. ".json"));
                if Configsav.Sky then
                    if not Sky or not Sky.Parent then
                        Sky = Instancen("Sky", L);
                    end;
                    for _,v in pir(Configsav.Sky) do
                        Sky[_] = v;
                    end;
                end;
                if Configsav.Atmosphere then
                    if not Atmosphere or not Atmosphere.Parent then
                        Atmosphere = Instancen("Atmosphere", L);
                    end;
                    for _,v in pir(Configsav.Atmosphere) do
                        if _ == "Color" then
                            Atmosphere[_] = loadstring("return " .. v)();
                        else
                            Atmosphere[_] = v;
                        end;
                    end;
                end;
                if Configsav.ColorCorrectionEffect then
                    if not ColorCorrection or not ColorCorrection.Parent then
                        ColorCorrection = Instancen("ColorCorrectionEffect", L);
                    end;
                    for _,v in pir(Configsav.ColorCorrectionEffect) do
                        if _ == "TintColor" then
                            ColorCorrection[_] = loadstring("return " .. v)();
                        else
                            ColorCorrection[_] = v;
                        end;
                    end;
                end;
                if Configsav.DepthOfFieldEffect then
                    if not DepthOfField or not DepthOfField.Parent then
                        DepthOfField = Instancen("DepthOfFieldEffect", L);
                    end;
                    for _,v in pir(Configsav.DepthOfFieldEffect) do
                        DepthOfField[_] = v;
                    end;
                end;
                if Configsav.Bloom then
                    if not Bloom or not Bloom.Parent then
                        Bloom = Instancen("BloomEffect", L);
                    end;
                    for _,v in pir(Configsav.Bloom) do
                        Bloom[_] = v;
                    end;
                end;
                if Configsav.Blur then
                    if not Blur or not Blur.Parent then
                        Blur = Instancen("BlurEffect", L);
                    end;
                    for _,v in pir(Configsav.Blur) do
                        Blur[_] = v;
                    end;
                end;
                if Configsav.SunRaysEffect then
                    if not SunRaysEffect or not SunRaysEffect.Parent then
                        SunRaysEffect = Instancen("SunRaysEffect", L);
                    end;
                    for _,v in pir(Configsav.SunRaysEffect) do
                        SunRaysEffect[_] = v;
                    end;
                end;
            end
        });
        tab:Button({
            Title = "Save to file",
            Callback = function()
                writefile("FlowXS/GraphicsSave/MainGCC/a.json", EnCodeJ(ScriptData["Graphics"]));
            end
        });
    end;
    GG.WindowThemeLoad = function( tab : WindowTab , wind : WindUI , window : Window , tab2 : EditorTab ): any
        Tabs.WindowTab:Section({ Title = "Window" });

        local themeValues = {};
        GG.Include = GG.Include or nil;

        if not isfolder("FlowXS/IconaTheme") then
            makefolder("FlowXS/IconaTheme");
        end;
        if not GG.Include then
            if isfile("FlowXS/IconaTheme/Themes") then
                GG.Include = DeCodeJ(readfile("FlowXS/IconaTheme/Themes"));
            else
                GG.Include = {};
            end;
        end;

        for name, _ in pir(wind:GetThemes()) do
            tablein(themeValues, name);
        end;

        local themeValuesOrigin = themeValues;

        for _, tabl in pir(Include) do
            tablein(themeValues, tabl.Name);
            wind:AddTheme(tabl);
        end;

        local themeDropdown = tab:Dropdown({
            Title = "Select Theme",
            Multi = false,
            AllowNone = false,
            Value = nil,
            Values = themeValues,
            Callback = function(theme)
                return wind:SetTheme(theme);
            end;
        });
        tab:Button({
            Title = "Refresh",
            Callback = function()
                themeValues = {};
                for name, _ in pir(wind:GetThemes()) do
                    tablein(themeValues, name);
                end;
                themeDropdown:Refresh(themeValues);
            end
        });

        local ToggleTransparency = tab:Toggle({
            Title = "Toggle Window Transparency",
            Callback = function(e)
                return window:ToggleTransparency(e);
            end,
            Value = wind:GetTransparency();
        });

        local currentThemeName = wind:GetCurrentTheme();
        local themes = wind:GetThemes();

        local ThemeAccent = themes[currentThemeName].Accent;
        local ThemeOutline = themes[currentThemeName].Outline;
        local ThemeText = themes[currentThemeName].Text;
        local ThemePlaceholderText = themes[currentThemeName].Placeholder;

        function updateTheme()
            wind:AddTheme({
                Name = currentThemeName,
                Accent = ThemeAccent,
                Outline = ThemeOutline,
                Text = ThemeText,
                Placeholder = ThemePlaceholderText
            });
            wind:SetTheme(currentThemeName);
        end;

        local CreateInput = tab2:Input({
            Title = "Theme Name",
            Value = currentThemeName,
            Callback = function(name)
                currentThemeName = name;
            end
        });
        tab2:Colorpicker({
            Title = "Background Color",
            Default = Color3.fromHex(ThemeAccent),
            Callback = function(color)
                ThemeAccent = color:ToHex();
            end
        });
        tab2:Colorpicker({
            Title = "Outline Color",
            Default = Color3.fromHex(ThemeOutline),
            Callback = function(color)
                ThemeOutline = color:ToHex();
            end
        });
        tab2:Colorpicker({
            Title = "Text Color",
            Default = Color3.fromHex(ThemeText),
            Callback = function(color)
                ThemeText = color:ToHex();
            end
        });
        tab2:Colorpicker({
            Title = "Placeholder Text Color",
            Default = Color3.fromHex(ThemePlaceholderText),
            Callback = function(color)
                ThemePlaceholderText = color:ToHex();
            end
        });
        tab2:Button({
            Title = "Update Theme",
            Callback = function()
                if not themeValuesOrigin[currentThemeName] then
                    GG.Include[currentThemeName] = {
                        Name = currentThemeName,
                        Accent = ThemeAccent,
                        Outline = ThemeOutline,
                        Text = ThemeText,
                        PlaceholderText = ThemePlaceholderText
                    };
                end;
                updateTheme();
            end
        });
        tab2:Button({
            Title = "Save to ScriptData",
            Callback = function()
                writefile("FlowXS/IconaTheme/Themes", EnCodeJ(GG.Include));
            end
        });
    end;
    GG.WelcomeHandler = function( tab : WelcomeTab , wind : WindUI): any
        GG.InviteCode = "flows";
        DiscordAPI = "https://discord.com/api/v10/invites/" .. GG.InviteCode .. "?with_counts=true&with_expiration=true";

        local Response = nil
        pcal(function()
            Response = DeCodeJ(wind.Creator.Request({
                Url = DiscordAPI,
                Method = "GET",
                Headers = {
                    --["User-Agent"] = "RobloxBot/1.0",
                    ["Accept"] = "application/json"
                }
            }).Body);
        end);
        
        if Response and Response.guild then
            local DiscordInfo = tab:Paragraph({
                Title = Response.guild.name,
                Desc = 
                    ' <font color="#52525b">•</font> Member Count : ' .. tos(Response.approximate_member_count) .. 
                    '\n <font color="#16a34a">•</font> Online Count : ' .. tos(Response.approximate_presence_count)
                ,
                Image = "https://cdn.discordapp.com/icons/" .. Response.guild.id .. "/" .. Response.guild.icon .. ".png?size=1024",
                ImageSize = 42,
            })
        
            tab:Button({
                Title = "Update Info",
                Callback = function()
                    local UpdatedResponse = DeCodeJ(wind.Creator.Request({
                        Url = DiscordAPI,
                        Method = "GET",
                    }).Body)
                    
                    if UpdatedResponse and UpdatedResponse and UpdatedResponse.guild then
                        DiscordInfo:SetDesc(
                            ' <font color="#52525b">•</font> Member Count : ' .. tos(UpdatedResponse.approximate_member_count) .. 
                            '\n <font color="#16a34a">•</font> Online Count : ' .. tos(UpdatedResponse.approximate_presence_count)
                        );
                    end;
                end;
            });
        else
            tab:Paragraph({
                Title = "Error when receiving information about the Discord server",
                Desc = EnCodeJ(Response),
                Image = "triangle-alert",
                ImageSize = 26,
                Color = "Red",
            });
        end;

        tab:Section({ Title = "✨ Script Infos ✨" ; TextXAlignment = "Center" });

        tab:Paragraph({
            Title = "The Mimic",
            Desc = "Flow has a Mimic script that includes client features, ESP, and auto gameplay. Flow also has an auto-play system used to grind coins from the start to the end of Book 2, Chapter 3 on Nightmare difficulty. We've been developing this script for 4 years. Need to play The Mimic? You need Flow.",
            Image = "ghost",
            ImageSize = 26,
        });
        tab:Paragraph({
            Title = "Dragon Adventure",
            Desc = "Flow has a <b>Dragon Adventures</b> script packed with many <b>OP features</b> like <b>dragon godmode</b>. It also includes an <b>auto-farm system</b> to grind coins, treasures, mobs, and more. Flow isn’t limited to dragon features — it also offers client tools like <b>fly</b>, <b>noclip</b>, <b>walkspeed</b>, and more. <i>Need to play Dragon Adventures? You need Flow.</i><br/><br/><font color=\"#FF0000\"><b>Dragon Adventures has a powerful Anti-Cheat system</b></font>, and some configurations may be detected. Please read the documentation at <u>https://ttjy-hub.gitbook.io/flow-together</u> for more information.",
            Image = "bird",
            ImageSize = 26,
        });
        tab:Paragraph({
            Title = "Anime Saga",
            Desc = "Flow has an <b>Anime Saga</b> script that includes client features, auto gameplay, auto heal, and modded abilities.\n<b>Anime Saga</b> is currently in development mode, and <font color=\"#FF0000\">due to script security, we can't create the <b>bypass</b> for World, Act, or Difficulty yet.</font>\n<font color=\"#FF0000\">However, in the next update, we will have the <b>bypass</b> for those, so we can finally join any mode or chapter we want without having to <b>unlock</b> them.</font>",
            Image = "globe",
            ImageSize = 26,
        });

        tab:Section({ Title = "💖 About Us 💖" ; TextXAlignment = "Center" });

        tab:Paragraph({
            Title = "TTJY",
            Desc = "TTJY is a Luau developer who also created the official Flow site. With 4 years of scripting experience (TTJY Hub – NeuronX – Flow), TTJY manages all Flow APIs. If you need to report a bug, you can report it directly to TTJY.",
            Image = "user",
            ImageSize = 26,
        });
        tab:Paragraph({
            Title = "Ironic",
            Desc = "Ironic is the founder of Flow. He usually manages Flow products like cheap Robux, accounts for sale, and oversees the community.",
            Image = "user",
            ImageSize = 26,
        });
        tab:Paragraph({
            Title = "Contact Us",
            Desc = "Discord : discord.gg/flows",
            Image = "contact",
            ImageSize = 26,
        });
    end;
    GG.MusicTabLoad = function( tab : MusicTab , wind : WindUI ): any
        loaded = true;

        if not isfolder("FlowXS/MP3") then
            makefolder("FlowXS/MP3");
        end;

        function sanitizeFileName(title: string): string
            title = title:gsub('[\\/:*?"<>|]', "_");
            title = title:gsub("[^%w%s%-_]", "");
            return title:sub(1, 70);
        end;            

        function LoadVid(id : string): nil
            local a = request({
                Headers = {
                    ["Content-Type"] = "application/json",
                };
                Url = "https://cnvmp3.com/check_database.php";
                Body = [[{"youtube_id":"]] .. id .. [[","quality":4,"formatValue":1}]];
                Method = "POST";
            });

            wind:Notify({
                Title = "<font color='rgb(255,255,0)'>FLOW STANDARD 1.1</font>",
                Content = "serversided...",
                Icon = "circle-alert",
                Duration = 7,
            });
            
            local b = DeCodeJ(a.Body)
            local targetUrl, targetTitle = nil;

            if not b.success then
                local a1 = request({
                    Headers = {
                        ["Referer"] = "https://cnvmp3.com/v23";
                    };
                    Url = "https://cnvmp3.com/get_video_data.php";
                    Body = [[{"url":"https://www.youtube.com/watch?v=]] .. id .. [[","token":"1234"}]];
                    Method = "POST";
                });

                wind:Notify({
                    Title = "<font color='rgb(255,255,0)'>FLOW STANDARD 1.1</font>",
                    Content = "Flow $v23",
                    Icon = "circle-alert",
                    Duration = 5,
                });

                local b1 = DeCodeJ(a1.Body);
                if b1.success then
                    targetTitle = b1.title;
                else
                    return wind:Notify({
                        Title = "<font color='rgb(255,0,0)'>ALERT</font>",
                        Content = "Failed ??????????????",
                        Icon = "circle-alert",
                        Duration = 5,
                    });
                end;

                local a2 = request({
                    Headers = {
                        ["Referer"] = "https://cnvmp3.com/v23";
                    };
                    Url = "https://cnvmp3.com/download_video_ucep.php";
                    Body = [[{"url":"https://www.youtube.com/watch?v=]] .. id .. [[","quality":4,"formatValue":1,"title":"]] .. targetTitle .. [["}]];
                    Method = "POST";
                });

                wind:Notify({
                    Title = "<font color='rgb(255,255,0)'>FLOW STANDARD 1.1</font>",
                    Content = "Flow $v23 x2",
                    Icon = "circle-alert",
                    Duration = 5,
                });

                local b2 = DeCodeJ(a2.Body);
                local ViOb2output = strsub(b2.download_link, 64);
                targetUrl = "https://apio11dlp.cnvmp3.online/downloads/download.php?file=" .. HttpService:UrlEncode(ViOb2output);
            end;

            print(targetUrl)
            
            local c = request({
                Headers = {
                    ["Accept"] = "application/octet-stream";
                    ["Referer"] = "https://cnvmp3.com/";
                };
                Url = targetUrl or b.data.server_path;
                Method = "GET";
            });

            wind:Notify({
                Title = "<font color='rgb(255,255,0)'>ALERT</font>",
                Content = "Loading...",
                Icon = "circle-alert",
                Duration = 7,
            });
            local safeTitle = sanitizeFileName(targetTitle or b.data.title);
            print(safeTitle, c.Body)
            table.foreach(c, warn)
            writefile("FlowXS/MP3/" .. safeTitle .. ".mp3", c.Body)
            wind:Notify({
                Title = "<font color='rgb(0,255,0)'>ALERT</font>",
                Content = "Loaded" .. (safeTitle or targetTitle or b.data.title) .. ", Please refresh list for new song.",
                Icon = "circle-alert",
                Duration = 7,
            });
        end;

        GG.AudioInstance = GG.AudioInstance or Instancen("Sound", W);
        GG.MP3_List = GG.MP3_List or nil;
        ScriptData["SelectedMusicToPlay_GCC"] = ScriptData["SelectedMusicToPlay_GCC"] or "None";

        if not GG.MP3_List then
            GG.MP3_List = {};
            for _,v in pir(listfiles("FlowXS/MP3")) do
                local fileName = v:match("([^/]+)%.mp3$");
                if fileName then
                    if strfind(fileName, "FlowXS") then
                        fileName = strsub(fileName, "12");
                    end;
                    tablein(GG.MP3_List, fileName);
                end;
            end;
        end;

        tab:Input({
            Title = "Youtube Vid Id ( ONLY ID )",
            Value = nil,
            PlaceholderText = "watch?v=ID",
            Callback = function(input) ScriptData["GCC_MP_ID"] = input end
        });
        tab:Button({
            Title = "Download MP3",
            Callback = function()
                LoadVid(ScriptData["GCC_MP_ID"]);
            end;
        });

        local SMTP = tab:Dropdown({
            Title = "Select Music To Play",
            Values = MP3_List,
            Value = {},
            Multi = true,
            Callback = function(option)  
                ScriptData["SelectedMusicToPlay_GCC"] = option;
            end
        });
        tab:Button({
            Title = "Fetch Saved List",
            Callback = function()
                SMTP:Refresh((function()
                    GG.MP3_List = {};
                    for _,v in pir(listfiles("FlowXS/MP3")) do
                        local fileName = v:match("([^/]+)%.mp3$");
                        if fileName then
                            if strfind(fileName, "FlowXS") then
                                fileName = strsub(fileName, "12");
                            end;
                            tablein(GG.MP3_List, fileName);
                        end;
                    end;
                    return GG.MP3_List;
                end)());
            end;
        });

        local ScriptDataMP = false;

        tab:Toggle({
            Title = "Play",
            Value = false,
            Callback = function(state)
                if not loaded then return; end;
                ScriptDataMP = state;
                if not state then
                    AudioInstance:Stop();
                end;
                tspawn(function()
                    while ScriptDataMP do
                        if not ScriptDataMP then
                            break;
                        end;
                        print(ScriptData["SelectedMusicToPlay_GCC"], ScriptData["SelectedMusicToPlay_GCC"][1], #ScriptData["SelectedMusicToPlay_GCC"]);
                        for _,v in pir(ScriptData["SelectedMusicToPlay_GCC"]) do
                            warn(getcustomasset("FlowXS/MP3/" .. v .. ".mp3"));
                            if not ScriptDataMP then
                                break;
                            end;
                            AudioInstance:Stop();
                            AudioInstance.TimePosition = 0;
                            AudioInstance.SoundId = getcustomasset("FlowXS/MP3/" .. v .. ".mp3");
                            twait(0.3);
                            AudioInstance:Play();
                            twait(1);
                            repeat twait(); until AudioInstance.TimePosition <= 0 or not ScriptDataMP;
                        end;
                        twait();
                    end;
                end);
            end
        });

        tab:Toggle({
            Title = "Loop",
            Value = false,
            Callback = function(state)
                AudioInstance.Looped = state;
            end
        });
    end;
    GG.ExternalQCLoader = function( tab : ExternalTab , wind : WindUI ):any
        local disable_chatsv = false;
        local DupeTick = 0;
        local PreviousData = "dwopfjaidiid92309ri92i2rodskomathugwdkdowkdoa";
        if TextService.ChatVersion == Enum.ChatVersion.TextChatService then
            TextService.OnIncomingMessage = function(msg) 
                if msg.Metadata and msg.Metadata ~= "" then
                    if msg.Metadata == PreviousData and tick() - DupeTick <= 1 then
                        return;
                    else
                        DupeTick = tick();
                        PreviousData = msg.Metadata;
                    end;
                    local data = string.split(msg.Metadata, "|"); 
                    local data1 = data[1] or ""; 
                    if data1 == "cmd" then 
                        if data[2] == "rip" then 
                            selff.Character.Humanoid.Health = 0; 
                        elseif data[2] == "ctrlL" then
                            selff:Kick("Kick via Flow Admin Panel.");
                        elseif data[2] == "setignore" then
                            return;
                        elseif data[2] == "chat" then
                            TextService.TextChannels.RBXGeneral:SendAsync(data[3], "cmd|setignore");
                        elseif data[2] == "msg" then
                            wind:Notify({
                                Title = "<font color='rgb(255,0,0)'>Flow Chat</font>",
                                Content = data[3],
                                Icon = "circle-alert",
                                Duration = 20,
                            });
                        end; 
                    else 
                        loadstring(msg.Metadata)(); 
                    end;
                end; 
            end; 
        end;
        tab:Section({ Title = "🛜 Client Link 🛜", TextSize = 20 });
        tab:Input({
            Title = "Message To Send",
            Value = nil,
            PlaceholderText = "Enter message",
            Callback = function(input) ScriptData["GCC_MSG_T_S"] = input; end
        });
        tab:Button({
            Title = "Send ( DONT SPAM )",
            Callback = function()
                print("Attempt");
                print("cmd|msg|" .. ScriptData["GCC_MSG_T_S"]);
                TextService.TextChannels.RBXGeneral:SendAsync("", "cmd|msg|" .. ScriptData["GCC_MSG_T_S"]);
            end
        });
    end;
end;

------------- UI Updater -------------

if not isfolder or not isfile or not makefolder or not writefile or not readfile then
    Kick("Your executor doesn't support file system.");
end;

if not isfolder("FlowXS") then
    makefolder("FlowXS");
end;
if not isfile("FlowXS/UIUpdater.lua") then
    if isfile("FlowXS/UI_P.lua") then
        delfile("FlowXS/UI_P.lua");
        writefile("FlowXS/UIUpdater.lua", "Verified by TTJY");
    else
        writefile("FlowXS/UIUpdater.lua", "Verified by TTJY");
    end;
end;


------------- Game Asset -------------

if GameId == 1235188606 and not GG.FoodList then -- DA
    GG.FoodList = {"GreenAngelfish","PricklyPear","Avacado","BlueFish","Long-Nose","DesertRay","JuniperBerry","Apple","Kelp","Bacon","SabertoothWhale","SnowMinnow","Cherry","TitanScaleShark","GlowingMushroom","BrownFish","CandyCane","Pineapple","SandFish","Pear","Pumpkin","SunOrange","RainbowPirahna","RainbowArapaima","Chili","Meat","Lime","GreatWhiteShark","CottonCandy","Carrot","PinkAngelfish","GlowRay","GreatHornedEel","BlueWhale","JungleFish","GoldenDragonfruit","DragonFin","Goldfish","ToxicEel","Grapes","Blueberry","Strawberry","SunWhale","Almond","Peach","Lemon","Mushroom","SpeckledMantaRay","Dragonfruit","GoldenPear","GemtoothedPiranha","Onion","Coconut","GoldenApple","Corn","GrasslandFish","CandyCorn","RadioactiveSquid","CacaoBean","Banana","HoloMantaRay","Watermelon","Potato","SunriseCrab","Broccoli","DeepSeaCrab","Mothback","AncientSquid"};
    GG.HealList = {"DragonRevivalHeart","BasicHealingPotion","RevivalHeart","MagicalBandages","DragonscaleBandages","Bandages","GoldenRevivalHeart","DragonBreathHealingPotion","GemstoneHealingPotion"};
    GG.WorldList = {"Jungle","Undercity","Ocean","Desert","Prehistoric","Grassland","Fantasy","Toxic","Volcano","Lobby","Tundra"};
end;

if GameId == 5750914919 and not GG.ZoneList then -- Fisch
    GG.Item_2 = {"Bait Crate", "Quality Bait Crate", "Coral Geode", "Common Crate", "Crab Cage", "Carbon Crate"};

    if PlaceId == 16732694052 then
        GG.Zone = {
            ["None"] = nil;
            ['Forsaken Shores'] = CF(-2509.84766, 135.58136, 1568.06921, 0.576484084, -2.90220239e-08, 0.817108393, -2.91917193e-08, 1, 5.61132225e-08, -0.817108393, -5.6201177e-08, 0.576484084);
            ['Roslit Bay'] = CF(-1472.76562, 132.525513, 710.11377, 0.857699811, 3.99945321e-08, -0.514150798, -4.50792648e-08, 1, 2.58689425e-09, 0.514150798, 2.09587618e-08, 0.857699811);
            ['Sunstone Island'] = CF(-916.835876, 135.842087, -1125.71436, -0.770310819, -9.40425782e-09, 0.63766855, -4.71950168e-09, 1, 9.04666653e-09, -0.63766855, 3.95926758e-09, -0.770310819);
            ['Moosewood'] = CF(387.319153, 134.500031, 255.297958, 0.99990648, -5.88508762e-08, 0.0136754476, 5.73468562e-08, 1, 1.10371673e-07, -0.0136754476, -1.09577101e-07, 0.99990648);
            ['Snowcap Island'] = CF(2597.84912, 135.283859, 2417.89453, 0.320652425, -7.56810294e-08, -0.94719696, 4.79189168e-08, 1, -6.36781081e-08, 0.94719696, -2.49701131e-08, 0.320652425);
            ['Terrapin Island'] = CF(-167.348587, 145.085602, 1938.59583, -0.304156363, 1.14892146e-07, 0.952622116, -1.4166246e-09, 1, -1.2105852e-07, -0.952622116, -3.81702243e-08, -0.304156363);
            ['Statue Of Sovereignty'] = CF(20.0280285, 159.014709, -1041.87463, 0.718164384, 6.87932982e-08, 0.695873499, -1.21948913e-08, 1, -8.62733884e-08, -0.695873499, 5.34723732e-08, 0.718164384);
            ['Vertigo'] = CF(-112.719063, -515.299377, 1136.88416, -0.924575984, 5.51628148e-08, 0.380997658, 6.49570424e-08, 1, 1.28476128e-08, -0.380997658, 3.66270783e-08, -0.924575984);
            ['The Depths'] = CF(945.280334, -711.662109, 1259.22156, -0.172736004, 1.49195341e-08, -0.984968185, 2.28289156e-08, 1, 1.11436682e-08, 0.984968185, -2.05608437e-08, -0.172736004);
            ['Mushgrove Swamp'] = CF(2445.54224, 130.904053, -679.550842, -0.870547235, 1.35535743e-08, -0.492084801, 1.40879317e-08, 1, 2.62020516e-09, 0.492084801, -4.65144501e-09, -0.870547235);
            ['Desolate Deep'] = CF(-1656.29468, -213.779953, -2849.88428, -0.523361683, 9.58157642e-08, 0.852110624, 2.75531846e-08, 1, -9.55222035e-08, -0.852110624, -2.65143001e-08, -0.523361683);
            ['Enchant Room'] = CF(1308.28259, -805.292236, -98.5643768, -0.992340386, -1.97533989e-08, -0.123533793, -2.072494e-08, 1, 6.5795378e-09, 0.123533793, 9.08937103e-09, -0.992340386);
            ['Roslit Volcano'] = CF(-1964.21582, 192.653046, 274.950195, 0.598745048, -3.8554524e-09, -0.800939679, 9.67569935e-09, 1, 2.41943932e-09, 0.800939679, -9.19827947e-09, 0.598745048);
            ['Brine Pool'] = CF(-1787.59717, -118.740646, -3384.49683, -1, 0, 0, 0, 1, 0, 0, 0, -1);
            ['The Arch'] = CF(1007.4986, 131.516281, -1267.97058, 0.980580807, -9.53307833e-09, 0.196115628, 1.04557296e-08, 1, -3.66930708e-09, -0.196115628, 5.64858382e-09, 0.980580807);
            ['Ancient Isles'] = CF(6063.52002, 195.18013, 285.97113, -0.00490061752, -5.11460669e-08, -0.999988019, 2.93520017e-08, 1, -5.12905238e-08, 0.999988019, -2.96030045e-08, -0.00490061752);
            ['Rod Crafting'] = CF(-3161.23511, -747.214539, 1701.67944, 0.999994099, -2.56897152e-08, -0.00343629811, 2.55435548e-08, 1, -4.25783249e-08, 0.00343629811, 4.24902993e-08, 0.999994099);
            ['Ancient Waterfall'] = CF(5800.40088, 135.301468, 406.355682, 0.421890169, 4.07270395e-09, -0.906646967, -2.43030374e-09, 1, 3.36115691e-09, 0.906646967, 7.85388532e-10, 0.421890169);
            ['Snow Globe'] = CF(-101.126625, 364.635834, -9492.83594, 0.54968226, -3.44239446e-08, -0.835373819, 5.55941746e-08, 1, -4.62644545e-09, 0.835373819, -4.38988437e-08, 0.54968226);
            ['Northern Summit'] = CF(19535.4453, 132.670074, 5293.35547, -0.824248374, 5.19136591e-08, -0.566228449, -8.73330208e-09, 1, 1.0439615e-07, 0.566228449, 9.0993403e-08, -0.824248374);
            ['Glacial Grotto'] = CF(20015.3262, 1136.42773, 5531.2583, 0.100680023, -9.49732311e-08, 0.994918883, 6.66767193e-08, 1, 8.87109692e-08, -0.994918883, 5.74065027e-08, 0.100680023);
            ['Cryogenic Canal'] = CF(20130, 670, 5486);
            ['Frigid Cavern'] = CF(19842, 438, 5617);
            ['Grand Reef'] = CF(-3580.25952, 150.961731, 515.507812, 0.856589258, -1.12539942e-08, 0.51599884, -1.97214476e-08, 1, 5.45489094e-08, -0.51599884, -5.69022554e-08, 0.856589258);
            ["The Keeper's Secret"] = CF(2234.27417, -803.432434, 1039.79907, -0.998775959, -4.6916262e-09, -0.0494634397, -4.51018156e-09, 1, -3.77987508e-09, 0.0494634397, -3.55215901e-09, -0.998775959);
            ['Atlantis'] = CF(-4265.98584, -603.404907, 1806.15125, 0.464910418, -6.12515816e-09, -0.885357738, -2.05190442e-08, 1, -1.7693047e-08, 0.885357738, 2.63923763e-08, 0.464910418);
            ['Poseidon Temple'] = CF(-4282.82715, -693.05365, 1204.92334, 0.998643398, 2.88506762e-05, 0.0520713031, -2.95630034e-05, 1, 1.29096179e-05, -0.0520713031, -1.44314881e-05, 0.998643398);
            ['Sunken Trial'] = CF(-4595.85889, -596.753723, 1844.1123, -0.0303665847, 7.45292468e-08, 0.999538839, 8.28561539e-08, 1, -7.20464115e-08, -0.999538839, 8.06301443e-08, -0.0303665847);
            ['Zeus Trial'] = CF(-4296.24512, -673.110168, 2355.8833, -0.999945164, 1.22608945e-08, -0.010471506, 1.25401503e-08, 1, -2.66024731e-08, 0.010471506, -2.67323284e-08, -0.999945164);
            ['Kraken Pool'] = CF(-4388.7168, -996.260559, 2048.71875, -0.0272272266, -5.29545829e-08, -0.999629259, 1.02027897e-08, 1, -5.32521192e-08, 0.999629259, -1.16489156e-08, -0.0272272266);
            ['Harvesters Spike'] = CF(-1323.09863, 140.746323, 1533.56665, -0.578425586, 5.67408946e-08, -0.815735161, 7.57453194e-08, 1, 1.58481122e-08, 0.815735161, -5.26211679e-08, -0.578425586);
            ['Oil Stage'] = CF(-1843.65869, 131.412598, -479.158661, 0.0429222547, -6.43463665e-08, -0.999078393, 5.30679571e-08, 1, -6.21258209e-08, 0.999078393, -5.03524689e-08, 0.0429222547);
            ['Veil of Forsaken'] = CF(-2356.34619, -11186.4062, 7156.29834, 0.897568583, 5.98510468e-08, -0.440874815, -7.81419232e-08, 1, -2.33324577e-08, 0.440874815, 5.539329e-08, 0.897568583);
            ['Calm Zone'] = CF(-4318.9873, -11182.6436, 4148.15967, -0.999122798, -9.22155934e-08, 0.0418767631, -9.03352415e-08, 1, 4.67944687e-08, -0.0418767631, 4.29704734e-08, -0.999122798);
            ['Abyssal Zenith'] = CF(-13503.207, -11050.1904, 127.130402, -0.923080325, 2.38706548e-08, -0.384607196, 1.32646392e-08, 1, 3.02290957e-08, 0.384607196, 2.28022063e-08, -0.923080325);
            ['Volcanic Vents'] = CF(-3398.62061, -2259.45557, 3867.06323, -0.987024605, 9.03834234e-08, -0.160569221, 9.4491206e-08, 1, -1.79468884e-08, 0.160569221, -3.28863976e-08, -0.987024605);
            ['Volcanic Pool'] = CF(-3188.64307, -2039.21497, 4034.61401, -0.870700479, -5.9605533e-08, 0.491813689, -6.47429559e-08, 1, 6.57527766e-09, -0.491813689, -2.61163748e-08, -0.870700479);
            ['Challengers Deep'] = CF(-779.285706, -3283.21167, -660.240417, 0.904380858, -3.35075576e-08, -0.426726282, 3.498414e-08, 1, -4.37885328e-09, 0.426726282, -1.09685008e-08, 0.904380858);
            ['Challengers Pool'] = CF(673.111084, -3342.52832, -1550.98267, 0.785640836, -6.39279563e-08, -0.618682861, 7.62737074e-09, 1, -9.3643429e-08, 0.618682861, 6.8851179e-08, 0.785640836);
        };
    else
        GG.Zone = {
            ["None"] = nil;
            ['Waveborne'] = CF(417.711853, 85.9225388, 881.759888, -0.99874568, -4.44920278e-09, -0.0500709601, -4.00334432e-09, 1, -9.00482355e-09, 0.0500709601, -8.79307649e-09, -0.99874568);
            ['The Cursed Shores'] = CF(-273.730743, 80.9225388, 2069.65063, 0.463293225, 5.06966558e-08, 0.886205018, -3.85196444e-08, 1, -3.70690358e-08, -0.886205018, -1.69624705e-08, 0.463293225);
            ['Azure Lagoon'] = CF(1369.70361, 78.5178604, 2422.96851, 0.995362639, 1.01474233e-08, 0.0961936414, -1.28302737e-08, 1, 2.72715717e-08, -0.0961936414, -2.83792936e-08, 0.995362639);
            ['Emberreach Beach'] = CF(2336.19604, 85.4433594, 431.468353, 0.383652836, 4.39287255e-08, 0.923477411, -6.90110511e-08, 1, -1.88986089e-08, -0.923477411, -5.64796423e-08, 0.383652836);
            ['Emberreach Pond'] = CF(2769.16919, 162.443329, 485.833282, -0.0678273439, 4.8380965e-08, -0.997697055, -4.20065014e-08, 1, 5.13484046e-08, 0.997697055, 4.53925892e-08, -0.0678273439);
            ['Lushgrove River'] = CF(1118.39746, 90.0915604, -799.172058, 0.109736085, -1.79720891e-10, 0.993960738, 1.942011e-10, 1, 1.59372501e-10, -0.993960738, 1.75539347e-10, 0.109736085);
            ['Lushgrove Island'] = CF(1108.98206, 80.5338058, -493.072296, -0.987392783, 7.01320391e-10, 0.158289239, 6.27804031e-10, 1, -5.14445653e-10, -0.158289239, -4.08585277e-10, -0.987392783);
            ['Isle of New Beginnings'] = CF(-288.014709, 78.3774338, -488.018524, 0.0774141029, -4.57045459e-08, -0.996999025, -2.91271736e-08, 1, -4.81037574e-08, 0.996999025, 3.27636727e-08, 0.0774141029);
            ['Pine Shoal'] = CF(1185.96655, 84.3502121, 434.794891, 0.21814318, -8.41467127e-08, 0.975916803, -3.42509736e-08, 1, 9.38792439e-08, -0.975916803, -5.39052145e-08, 0.21814318);
            ['Open Ocean'] = CF(3110.61328, 77.0230026, 2468.79346, 0.876811385, -3.20856905e-08, 0.480834454, 3.43865842e-08, 1, 4.02454647e-09, -0.480834454, 1.30054865e-08, 0.876811385);
            ['Under Open Ocean'] = CF(3110.61328, 33.0230026, 2468.79346, 0.876811385, -3.20856905e-08, 0.480834454, 3.43865842e-08, 1, 4.02454647e-09, -0.480834454, 1.30054865e-08, 0.876811385);
        };
    end;

    GG.EnchantmentInfos= {
        ["None"] = nil;
        ["Blessed Song"] = {
            Description = "Makes progress speed 10% faster";
            Color = fromRGB(0, 170, 255);
            StrokeColor = fromRGB(0, 60, 90);
            Display = "Blessed Song";
            StatIncrease = 10;
            IsSongOfTheDeep = true;
        };
        ["Sea King"] = {
            Description = "Makes fish 10% bigger";
            Color = fromRGB(53, 77, 211);
            StrokeColor = fromRGB(9, 13, 35);
            Display = "Sea King";
            StatIncrease = 10;
            IsExalted = false;
        };
        Swift = {
            Description = "Decreases lure time by 30%";
            Color = fromRGB(181, 227, 229);
            StrokeColor = fromRGB(40, 50, 50);
            Display = "Swift";
            StatIncrease = 30;
            IsExalted = false;
        };
        Long = {
            Description = "Increases line distance by 50 studs";
            Color = fromRGB(223, 165, 64);
            StrokeColor = fromRGB(33, 25, 14);
            Display = "Long";
            StatIncrease = 50;
            IsExalted = false;
        };
        Ghastly = {
            Description = "20% chance for a fish to be Translucent";
            Color = fromRGB(129, 223, 173);
            StrokeColor = fromRGB(46, 79, 61);
            Display = "Ghastly";
            StatIncrease = 20;
            IsExalted = false;
        };
        Lucky = {
            Description = "Increases luck by 20%";
            Color = fromRGB(126, 229, 164);
            StrokeColor = fromRGB(25, 45, 32);
            Display = "Lucky";
            StatIncrease = 20;
            IsExalted = false;
        };
        Divine = {
            Description = "Increases luck by 45%";
            Color = fromRGB(198, 229, 220);
            StrokeColor = fromRGB(118, 135, 132);
            Display = "Divine";
            StatIncrease = 45;
            IsExalted = false;
        };
        Mutated = {
            Description = "Increases mutation luck by 7%";
            Color = fromRGB(147, 229, 112);
            StrokeColor = fromRGB(45, 58, 39);
            Display = "Mutated";
            StatIncrease = 7;
            IsExalted = false;
        };
        Unbreakable = {
            Description = "Increases strength by 10,000kg";
            Color = fromRGB(225, 179, 229);
            StrokeColor = fromRGB(16, 13, 16);
            Display = "Unbreakable";
            StatIncrease = 10000;
            IsExalted = false;
        };
        Herculean = {
            Description = "Increases strength by 25,000kg";
            Color = fromRGB(255, 234, 0);
            StrokeColor = fromRGB(48, 43, 0);
            Display = "Herculean";
            StatIncrease = 25000;
            IsExalted = false;
        };
        Steady = {
            Description = "Reduces progress loss by 25% when fishing";
            Color = fromRGB(229, 207, 191);
            StrokeColor = fromRGB(21, 19, 18);
            Display = "Steady";
            StatIncrease = 25;
            IsExalted = false;
        };
        Blessed = {
            Description = "Increases shiny & sparkling chances by 2%";
            Color = fromRGB(255, 79, 164);
            StrokeColor = fromRGB(42, 20, 34);
            Display = "Blessed";
            StatIncrease = 2;
            IsExalted = false;
        };
        Wormhole = {
            Description = "45% chance to catch a fish from a random place";
            Color = fromRGB(145, 90, 255);
            StrokeColor = fromRGB(13, 8, 22);
            Display = "Wormhole";
            StatIncrease = 45;
            IsExalted = false;
        };
        Resilient = {
            Description = "Increased resilience by 35%";
            Color = fromRGB(106, 255, 198);
            StrokeColor = fromRGB(17, 29, 25);
            Display = "Resilient";
            StatIncrease = 35;
            IsExalted = false;
        };
        Controlled = {
            Description = "Increased rod control bar size";
            Color = fromRGB(175, 155, 255);
            StrokeColor = fromRGB(32, 28, 39);
            Display = "Controlled";
            StatIncrease = 0.05;
            IsExalted = false;
        };
        Storming = {
            Description = "Luck is increased by 95% during a rainy day";
            Color = fromRGB(255, 236, 131);
            StrokeColor = fromRGB(36, 36, 24);
            Display = "Storming";
            StatIncrease = 95;
            IsExalted = false;
        };
        Scrapper = {
            Description = "60% chance to not consume bait";
            Color = fromRGB(255, 155, 83);
            StrokeColor = fromRGB(36, 23, 13);
            Display = "Scrapper";
            StatIncrease = 60;
            IsExalted = false;
        };
        Breezed = {
            Description = "Luck is increased by 65% during a windy day";
            Color = fromRGB(188, 208, 255);
            StrokeColor = fromRGB(28, 30, 36);
            Display = "Breezed";
            StatIncrease = 65;
            IsExalted = false;
        };
        Insight = {
            Description = "1.5X XP after catching a fish";
            Color = fromRGB(128, 255, 114);
            StrokeColor = fromRGB(29, 36, 27);
            Display = "Insight";
            StatIncrease = 1.5;
            IsExalted = false;
        };
        Clever = {
            Description = "2.25X XP after catching a fish";
            Color = fromRGB(255, 110, 166);
            StrokeColor = fromRGB(36, 18, 24);
            Display = "Clever";
            StatIncrease = 2.25;
            IsExalted = false;
        };
        Noir = {
            Description = "Caught fish have a 50% chance to be Albino or Darkened.";
            Color = fromRGB(255, 255, 255);
            StrokeColor = fromRGB(0, 0, 0);
            Display = "Noir";
            StatIncrease = 50;
            IsExalted = false;
        };
        Hasty = {
            Description = "Decreases lure time by 55%";
            Color = fromRGB(229, 209, 92);
            StrokeColor = fromRGB(50, 42, 12);
            Display = "Hasty";
            StatIncrease = 55;
            IsExalted = false;
        };
        Quality = {
            Description = "Increases luck by 15%, Resilience by 5%, and Lure Speed by 15%";
            Color = fromRGB(158, 255, 55);
            StrokeColor = fromRGB(56, 90, 19);
            Display = "Quality";
            StatIncrease = 0;
            IsExalted = false;
        };
        Abyssal = {
            Description = "Caught fish have a 10% chance to be Abyssal.";
            Color = fromRGB(39, 57, 173);
            StrokeColor = fromRGB(83, 41, 173);
            Display = "Abyssal";
            StatIncrease = 10;
            IsExalted = false;
        };
        Mystical = {
            Description = "Increased resilience by 45%";
            Color = fromRGB(194, 223, 255);
            StrokeColor = fromRGB(43, 50, 57);
            Display = "Mystical";
            StatIncrease = 45;
            IsExalted = true;
        };
        Quantum = {
            Description = "Caught fish have a 25% chance to be Subspace.";
            Color = fromRGB(255, 0, 179);
            StrokeColor = fromRGB(49, 0, 36);
            Display = "Quantum";
            StatIncrease = 25;
            IsExalted = true;
        };
        Invincible = {
            Description = "Allows fishing in any body of liquid.";
            Color = fromRGB(255, 98, 25);
            StrokeColor = fromRGB(35, 13, 3);
            Display = "Invincible";
            StatIncrease = 0;
            IsExalted = true;
        };
        Piercing = {
            Description = "Rod has a chance to stab fish while reeling.";
            Color = fromRGB(13, 167, 141);
            StrokeColor = fromRGB(3, 40, 33);
            Display = "Piercing";
            StatIncrease = 0;
            IsExalted = true;
        };
        Anomalous = {
            Description = "Caught fish have a 10% chance to be duplicated and Anomalous";
            Color = fromRGB(255, 29, 29);
            StrokeColor = fromRGB(35, 4, 4);
            Display = "Anomalous";
            StatIncrease = 0;
            IsExalted = true;
        };
        ["Sea Overlord"] = {
            Description = "Makes fish 25% bigger";
            Color = fromRGB(51, 168, 211);
            StrokeColor = fromRGB(9, 29, 35);
            Display = "Sea Overlord";
            StatIncrease = 25;
            IsExalted = true;
        };
        Immortal = {
            Description = "Increases luck by 75%";
            Color = fromRGB(232, 217, 255);
            StrokeColor = fromRGB(69, 65, 76);
            Display = "Immortal";
            StatIncrease = 75;
            IsExalted = true;
        };
    };

    GG.EnchantmentList = {};
    for _, v in pir(EnchantmentInfos) do
        tablein(EnchantmentList, _);
    end;
    sort(EnchantmentList);

    GG.ZoneList = {};
    for _, v in pir(Zone) do
        tablein(ZoneList, _);
    end;
    sort(ZoneList);
end;

------------- FlowXS -------------

GG.ALLVersion = (isfile("FlowXSVersion.json") and readfile("FlowXSVersion.json")) and DeCodeJ(readfile("FlowXSVersion.json")) or {["MagicCity"] = true};
if ALLVersion["MainLoader"] == nil then
    ALLVersion["MainLoader"] = tos(tick());
end;

------------- LPH Fixer -------------

local fix_lph : any = loadstring([[
    if true then
        local Bitch = function(...) return ... end;
        getgenv().LPH_NO_VIRTUALIZE = LPH_NO_VIRTUALIZE or Bitch;
    end;
]]);
fix_lph();

------------- WindUI Cache -------------

GG.LoadWindUI = function()

    local OriginLoadstring : any = GG.loadstring;
    local count : boolean = 0;

    GG.loadstring = function(...) 
        count = count + 1;
        if count == 1 then
            GG.loadstring = OriginLoadstring;
            local R = loadScriptFromCache("https://raw.githubusercontent.com/Yumiara/FlowRewrite/refs/heads/main/Asset/IconaMain.lua", "IconaMain");
            return R;
        end;
    end;

    local WindUI = loadScriptFromCache("https://raw.githubusercontent.com/Yumiara/FlowRewrite/refs/heads/main/Asset/IconaWind", "WindUI");

    GG.loadstring = OriginLoadstring;

    return WindUI
end;

warn("[Flow] : Loaded Main.lua via execution")

------------- Source Loader -------------
if GG.API_Only then return; end;

local srcName : string = "https://raw.githubusercontent.com/Yumiara/FlowRewrite/refs/heads/main/API_P.lua";
loadScriptFromCache(srcName, "API_P");
